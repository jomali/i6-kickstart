
!!==============================================================================
!!
!!	EL BARÓN
!!	Objeto con rutinas de utilidad
!!
!!==============================================================================
!!
!!	Archivo:		baron_utils.inf
!!	Autor(es):		Victor Gijsbers
!!					J. Francisco Martín <jfm.lisaso@gmail.com>
!!	Idioma:			ES (Español)
!!	Sistema:		Inform-INFSP 6
!!	Plataforma:		Máquina-Z/Glulx
!!	Versión:		0.0
!!	Fecha:			2019/02/XX
!!
!!------------------------------------------------------------------------------
!!
!!	Este archivo forma parte de la ficción interactiva EL BARÓN.
!!
!!	EL BARÓN es software libre: usted puede redistribuirlo y/o
!!	modificarlo bajo los términos de la Licencia Pública General
!!	GNU publicada por la Fundación para el Software Libre, ya
!!	sea la versión 3 de la Licencia, o (a su elección) cualquier
!!	versión posterior.
!!
!!	EL BARÓN se distribuye con la esperanza de que sea útil,
!!	pero SIN GARANTÍA ALGUNA; ni siquiera la garantía implícita
!!	MERCANTIL o de APTITUD PARA UN PROPÓSITO DETERMINADO.
!!	Consulte los detalles de la Licencia Pública General GNU
!!	para más información.
!!
!!	Debería haber recibido una copia de la Licencia Pública
!!	General GNU junto a EL BARÓN. En caso contrario, consulte
!!	<http://www.gnu.org/licenses/>.
!!
!!	Copyright (c) 2004, Victor Gijsbers
!!	Copyright (c) 2019, J. Francisco Martín
!!
!!------------------------------------------------------------------------------

#Ifdef TARGET_GLULX;
#Ifdef USE_VORPLE;
Array _hyperlinks_utility_array_a buffer LEN_HUGEHUGESTR;
#Endif; ! USE_VORPLE;
#Endif; ! TARGET_GLULX;

Object	Utils "(Utilities)"
 with	!!----------------------------------------------------------------------
		!! Comprueba si un objto contenedor/soporte 'obj' tiene capacidad
		!! suficiente para contener un segundo objeto 'second', pasados ambos
		!! como parámetro.
		!!
		!!	@param {Object} obj - Objeto contenedor/soporte
		!!	@param {Object} second - Objeto que se comprueba si puede ser
		!!		contenido en 'obj'
		!!	@returns {integer} Código con el resultado de la comprobación:
		!!		0) si no se usa la extensión 'capacities.h'
		!!		1) 'obj' tiene capacidad para albergar a 'second'
		!!		-1) se supera la cantidad máxima de objs. que puede tener 'obj'
		!!		-2) se supera la capacidad de tamaño máximo de 'obj'
		!!		-3) se supera la capacidad de volumen máximo de 'obj'
		!!		-4) el volumen agregado supera la capacidad máxima de 'obj'
		!!		-5) se supera la capacidad de peso máximo de 'obj'
		!!		-6) el peso agregado supera la capacidad máxima de 'obj'
		!!	@dependency capacities.h
		!!	@version 2019/07/15
		!!----------------------------------------------------------------------
		check_object_capacity [ obj second;
			!! Rutina definida por la extensión 'capacities.h':
			return CheckIfObjectFits(obj, second);
		],
		!!----------------------------------------------------------------------
		!! Crea un hipervínculo en Vorple.
		!! FIXME doc?
		!!----------------------------------------------------------------------
		create_vorple_hyperlink [ item alternative;
			#Ifdef USE_VORPLE;
			if (isVorpleSupported()) {
				bp_output_stream(3, _hyperlinks_utility_array_a, LEN_HUGEHUGESTR);
				self.print_object_short_name(item);
				bp_output_stream(-3);
				if (alternative) {
					VorpleLinkCommandText(_hyperlinks_utility_array_a, alternative);
				} else {
					VorpleLinkCommand(_hyperlinks_utility_array_a);
				}
			} else {
				if (alternative) print (string) alternative;
				else self.print_object_short_name(item);
			}
			#Endif; ! USE_VORPLE;
			item = alternative = 0; ! (por evitar alertas del compilador)
			return true;
		],
		!!----------------------------------------------------------------------
		!! Elimina los contenidos de todas las ventanas de la interfaz.
		!!
		!!	@returns {boolean} Verdadero
		!!	@version 2019/07/15
		!!----------------------------------------------------------------------
		erase_window [;
		    #Ifdef TARGET_ZCODE;
		    @erase_window -1;
		    #Ifnot; ! TARGET_GLULX
		    if (gg_quotewin) {
				glk($0024, gg_quotewin, 0); ! close_window
				gg_quotewin = 0;
		    }
		    glk($002A, gg_mainwin); ! window_clear
		    if (gg_statuswin) glk($002A, gg_statuswin); ! window_clear
		    #Endif;
			return true;
		],
		!!----------------------------------------------------------------------
		!! Realiza un efecto de subida de volumen gradual de un recurso de
		!! audio. Permite especificar si el efecto se realiza en tiempo real
		!! —por defecto— o deteniendo la aplicación mientras se produce. En
		!! caso de que el recurso no se encontrase en reproducción, se inicia
		!! antes con un volumen del 0%. Si no se especifica el tiempo del
		!! efecto, la subida de volumen es inmediata.
		!!
		!! Debe tenerse en cuenta que no pueden lanzarse dos efectos de 'fade'
		!! al mismo tiempo —el temporizador Glk sólo puede ser utilizado por
		!! una operación en un momento dado—. Si ya hay un efecto en ejecución,
		!! los nuevos efectos no se lanzan; los nuevos sonidos se reproducirán
		!! directamente con el volumen final, sin subidas o bajadas graduales
		!! de volumen.
		!!
		!! Las funcionalidades multimedia sólo son soportadas en Glulx.
		!!
		!!	@param {Sound} track - El recurso de audio sobre el que se lanza
		!!		el efecto. Si el recurso no estaba en reproducción primero se
		!!		inicia con un volumen del 0%
		!!	@param {integer} [volume=-1] - Volumen final en tanto por ciento
		!!		con el que finaliza el efecto. -1 para indicar el volumen
		!!		global de la aplicación. Si el volumen actual es mayor que
		!!		'volume', retorna sin hacer nada
		!!	@param {integer} [fade_time=0] - Milisegundos que dura el efecto de
		!!		'fade-in' desde el volumen actual del recurso de audio hasta
		!!		el especificado por 'volume'
		!!	@param {boolean} [simple_fade_in=false] - Por defecto el efecto se
		!!		realiza en tiempo real, pero si se invoca con este parámetro
		!!		activado (verdadero), la aplicación se detiene mientras se
		!!		lleva a cabo el 'fade-in'
		!!	@returns {boolean} Verdadero si la versión compilada utiliza
		!!		recursos multimedia y se lanza el efecto con éxito. Falso en
		!!		caso contrario
		!!	@version 1.0
		!!----------------------------------------------------------------------
		fade_in [ track volume fade_time simple_fade_in
			result js_track;
			!! FIXME - si el volumen pasado como parámetro < volumen actual
			!! FIXME - simple_fade_in
			result = false;
			#Ifdef TARGET_GLULX;

			#Ifdef USE_DAMUSIX;
			if (volume == 0) {
				volume = -1;
			}
			if (fade_time == 0 || Damusix.EnFade()) {
				Damusix.Volumen(track, volume);
				if (~~Damusix.SonandoDeFondo(track)) {
					Damusix.Tocar(track);
				}
			} else {
				if (~~Damusix.SonandoDeFondo(track)) {
					Damusix.Volumen(track, 0);
					Damusix.Tocar(track);
				}
				Damusix.FadeIn(track, fade_time, volume);
			}
			result = true;
			#Endif; ! USE_DAMUSIX;

			#Ifdef USE_VORPLE;
			if (isVorpleSupported()) {
				switch (track) {
					!! TODO
					!! SFX_WIND:
					!! 	js_track = "jsWindSFX";
					!! 	VorpleExecuteJavaScriptCommand("
					!! 		var jsWindSFX = new Howl({
					!! 			src: ['resources/audio/bdvictor_wheat-in-the-wind.ogg'],
					!! 			loop: true,
					!! 			volume: 1.0
					!! 		});
					!! 	");
					!! 	VorpleExecuteJavaScriptCommand(BuildCommand("
					!! 		", js_track, ".volume(0);
					!! 		", js_track, ".play();
					!! 		result = ", js_track, ".fade(0.0, 1.0, 100);
					!! 		console.log('Fade-in: ' + result);
					!! 	"));
				}
				result = true;
			} else {
				result = false;
			}
			#Endif; ! USE_VORPLE;

			#Endif; ! TARGET_GLULX;
			!! (por evitar alertas del compilador)
			track = volume + fade_time + simple_fade_in + js_track;
			return result;
		],
		!!----------------------------------------------------------------------
		!! Realiza un efecto de bajada de volumen gradual de un recurso de
		!! audio. Permite especificar si el efecto se realiza en tiempo real
		!! —por defecto— o deteniendo la aplicación mientras se produce, y si
		!! debe reproducirse un nuevo recurso de audio una vez finalizado el
		!! efecto.
		!!
		!! Debe tenerse en cuenta que no pueden lanzarse dos efectos de 'fade'
		!! al mismo tiempo —el temporizador Glk sólo puede ser utilizado por
		!! una operación en un momento dado—. Si ya hay un efecto en ejecución,
		!! los nuevos efectos no se lanzan; los nuevos sonidos se reproducirán
		!! directamente con el volumen final, sin subidas o bajadas graduales
		!! de volumen.
		!!
		!! Las funcionalidades multimedia sólo son soportadas en Glulx.
		!!
		!!	@param {Sound} track - El recurso de audio sobre el que se lanza
		!!		el efecto
		!!	@param {integer} [volume=0] - Volumen final en tanto por ciento con
		!!		el que finaliza el efecto. Si el volumen final es 0, la
		!!		reproducción se detiene automáticamente. Si el volumen actual
		!!		es inferior que 'volume', retorna sin hacer nada
		!!	@param {integer} [fade_time=0] - Milisegundas que dura el efecto de
		!!		'fade-out' desde el volumen actual del recurso de audio hasta
		!!		el especificado por 'volume'
		!!	@param {boolean} [simple_fade_in=false] - Por defecto el efecto se
		!!		realiza en tiempo real, pero si se invoca con este parámetro
		!!		activado (verdadero), la aplicación se detiene mientras se
		!!		lleva a cabo el 'fade-out'
		!!	@param {Sound} [post_track=0] - Recurso de audio a reproducir tras
		!!		efectuar el efecto de 'fade-out' sobre 'track'
		!!	@returns {boolean} Verdadero si la versión compilada utiliza
		!!		recursos multimedia y se lanza el efecto con éxito. Falso en
		!!		caso contrario
		!!	@version 4.1
		!!----------------------------------------------------------------------
		fade_out [ track volume fade_time simple_fade_out post_track
			result js_track;
			result = false;
			#Ifdef TARGET_GLULX;

			#Ifdef USE_DAMUSIX;
			if (Damusix.QueVolumen(track) > 0) {
				if (fade_time == 0 || Damusix.EnFade()) {
					if (volume == 0) Damusix.Parar(track);
					else Damusix.Volumen(track, volume);
					if (post_track) Damusix.Tocar(post_track);
				} else {
					if (simple_fade_out) {
						Damusix.SimpleFadeOut(track, fade_time, volume);
						if (post_track) Damusix.Tocar(post_track);
					} else {
						Damusix.FadeOut(track, fade_time, volume, post_track);
					}
				}
				result = true;
			}
			#Endif; ! USE_DAMUSIX;

			#Ifdef USE_VORPLE;
			if (isVorpleSupported()) {
				switch (track) {
					!! TODO
					!! SFX_WIND:		js_track = "jsWindSFX";
				}
				!! VorpleExecuteJavaScriptCommand(BuildCommand("
				!! 	if (", js_track, ".playing()) {
				!! 		result = ", js_track, ".fade(1.0, 0.0, 200);
				!! 		console.log('Fade out: ' + result);
				!! 	}
				!! "));
				result = true;
			} else {
				result = false;
			}
			#Endif; ! USE_VORPLE;

			#Endif; ! TARGET_GLULX;
			!! (por evitar alertas del compilador)
			track = volume + fade_time + simple_fade_out + post_track
				+ js_track;
			return result;
		],
		!!----------------------------------------------------------------------
		!! Retorna el código numérico de la flexión gramatical actual utilizada
		!! por la obra, tal y como se definen en la extensión 'SpanishLM.h':
		!!
		!!	1)	Presente, primera persona
		!!	2)	Presente, segunda persona. (Valor por defecto).
		!!	3)	Presente, tercera persona
		!!	4)	Pasado, primera persona
		!!	5)	Pasado, segunda persona
		!!	6)	Pasado, tercera persona
		!!	7)	Futuro, primera persona
		!!	8)	Futuro, segunda persona
		!!	9)	Futuro, tercera persona
		!!
		!!	@returns {integer} Código numérico de la flexión gramatical actual
		!!	@version 2019/09/14
		!!----------------------------------------------------------------------
		get_grammatical_inflection [
			result;
			result = 2; ! (por defecto)
			#Ifdef USE_SPANISH_LM;
			result = _grammatical_inflection;
			#Endif; ! USE_SPANISH_LM;
			return result;
		],
		!!----------------------------------------------------------------------
		!! Retorna el código numérico del estilo de texto de las palabras
		!! destacadas para el tipo de objeto con el código pasado como
		!! parámetro.
		!!
		!!	@param {integer} object_type - Código numérico del tipo de objeto
		!!		para el que se pretende conocer el estilo de texto resaltado
		!!	@returns {integer} Código numérico del estilo de texto resaltado
		!!		para los objetos de tipo 'object_type'. -1 por defecto
		!!	@version 2019/09/14
		!!----------------------------------------------------------------------
		get_highlight_style [ object_type
			result;
			result = -1; ! (por defecto)
			if (((object_type-1) >= 0)
				&& ((object_type-1) < (self.#highlight_styles)/WORDSIZE)) {
				result = self.&highlight_styles-->(object_type-1);
			}
			return result;
		],
		!!----------------------------------------------------------------------
		!! Retorna el estado (si están o no activados) de los hipervínculos
		!! para el tipo de objeto con el código pasado como parámetro.
		!!
		!!	@param {integer} object_type - Código numérico del tipo de objeto
		!!		para el que se pretende conocer el estado de los hipervínculos
		!!	@returns {boolean} Verdadero si los hipervínculos para los objetos
		!!		de tipo 'object_type' están activados. Falso en caso contrario
		!!	@version 1.1
		!!----------------------------------------------------------------------
		get_hyperlinks_status [ object_type
			result;
			result = false; ! (por defecto)
			if (((object_type-1) >= 0)
				&& ((object_type-1) < (self.#hyperlinks_status)/WORDSIZE)) {
				result = self.&hyperlinks_status-->(object_type-1);
			}
			return result;
		],
		!!----------------------------------------------------------------------
		!! Retorna el código numérico del estilo de texto utilizado actualmente
		!! por la obra, tal y como se definen en la extensión 'textStyle.h':
		!!
		!!	1) recto
		!!	2) enfático
		!!	3) importante
		!!	4) monoespaciado
		!!	5) encabezado
		!!	6) nota
		!!	7) cita
		!!	8) entrada
		!!	9) usuario 1
		!!	10) usuario 2
		!!
		!!	@returns {integer} Código numérico del estilo de texto utilizado
		!!		actualmente. 0 por defecto
		!!	@version 2019/09/14
		!!----------------------------------------------------------------------
		get_text_style [
			result;
			result = 0; ! (por defecto)
			#Ifdef TEXT_STYLES;
			result = _current_text_style;
			#Endif; ! TEXT_STYLES;
			return result;
		],
		!!----------------------------------------------------------------------
		!! Dado un objeto como parámetro retorna su antecesor más lejano en el
		!! árbol de objetos del modelo de mundo.
		!!
		!!	@param {Object} obj - Objeto del que se desea averiguar su
		!!		antecesor más lejano
		!!	@returns {Object} Antecesor más lejano de 'obj'
		!!	@version 2019/09/14
		!!----------------------------------------------------------------------
		get_top_holder [ obj
			aux;
			while (parent(obj) ~= 0) {
				aux = ObjectScopedBySomething(obj);
				if (aux == 0) aux = parent(obj);
				obj = aux;
			}
			return obj;
		],
		!!----------------------------------------------------------------------
		!! Rutina encargada de hacer las inicializaciones oportunas al ejecutar
		!! la obra sobre la máquina virtual GLULX: incializar la librería
		!! Vorple, activar la escucha de hipervínculos, inicializar los
		!! recursos multimedia...
		!!
		!!	@returns {boolean} Verdadero
		!!	@version 2019/06/18
		!!----------------------------------------------------------------------
		initialise_glulx [;
			#Ifdef TARGET_GLULX;

			!! Inicializaciones de Vorple:
			#Ifdef USE_VORPLE;
			VorpleInitialise();
			#Endif; ! USE_VORPLE;

			!! Activa la escucha de eventos glk para el uso de hipervínculos:
			#Ifdef USE_HYPERLINKS;
			ListenHyperlinkEvents();
			#Endif; ! USE_HYPERLINKS;

			!! Inicializa los recursos multimedia:
			#Ifdef USE_DAMUSIX;
			!!	Damusix.AsignarCanal(
			!!		SONIDO,
			!!		CANAL [0-9],
			!!		VOLUMEN [0-100],
			!!		REPETICIONES (-1 para repeticiones infinitas)
			!!	);
			#Endif; ! USE_DAMUSIX;

			!! Comprueba el soporte multimedia del intérprete:
			#Ifdef VERSION_DESKTOP;
			if (~~glk($0004, 6, 0)			! glk_gestalt(gestalt_Graphics, 0)
				|| ~~glk($0004, 8, 0)		! glk_gestalt(gestalt_Sound, 0)
				|| ~~glk($0004, 13, 0)) {	! glk_gestalt(gestalt_SoundMusic, 0)
				new_line;
				print (strong) "ADVERTENCIA", "^";
				new_line;
				print "Esta aplicación incluye contenidos audiovisuales pero tu
				intérprete Glulx no los soporta adecuadamente. Se recomienda
				utilizar un intérprete diferente poder experimentar la obra con
				todos sus contenidos gráficos y de audio.^";
				new_line;
				new_line;
				print (parser) "Pulsa una tecla.";
				new_line;
				self.press_any_key();
				self.erase_window();
			}
			#Endif; ! VERSION_DESKTOP;

			!! Comprueba el soporte para la librería Vorple del intérprete:
			!! XXX - La comprobación sólo es efectiva si previamente se ha
			!! invocado "VorpleInitialise()"
			#Ifdef USE_VORPLE;
			if (~~isVorpleSupported()) {
				new_line;
				print (strong) "ADVERTENCIA", "^";
				new_line;
				print "Estás a punto de iniciar una ", (stressed) "versión
				reducida", " de la aplicación ideada para plataformas móviles
				que no incluye contenidos audiovisuales. Si estás ejecutando la
				obra desde una plataforma de escritorio se recomienda no
				utilizar esta versión y utilizar en su lugar la versión
				original.^";
				new_line;
				new_line;
				print (parser) "Pulsa una tecla.";
				new_line;
				self.press_any_key();
				self.erase_window();
			}
			#Endif; ! USE_VORPLE;

			#Endif; ! TARGET_GLULX;
			return true;
		],
		!!----------------------------------------------------------------------
		!! Indica si se utilizan o no los puntos cardinales como sistema de
		!! navegación.
		!!
		!!	@returns Verdadero si la navegación se realiza a través de los
		!!		puntos cardinales. Falso en caso contrario
		!!	@version 2019/09/14
		!!----------------------------------------------------------------------
		is_compass_enabled [;
			return self.compass_mode;
		],
		!!----------------------------------------------------------------------
		!! Reproduce un efecto de audio. En Damusix se utiliza uno de los
		!! canales virtuales.
		!!
		!! Las funcionalidades multimedia sólo son soportadas en Glulx.
		!!
		!!	@param {Sound} sound - Recurso de audio
		!!	@param {integer} [volume=100] - Volumen en tanto por ciento con el
		!!		que se reproduce el recurso de audio 'sound'
		!!	@returns {boolean} Verdadero si la versión compilada utiliza
		!!		recursos multimedia. Falso en caso contrario
		!!	@version 2.0
		!!----------------------------------------------------------------------
		play_sfx [ sound volume
			result;
			!! FIXME - gestionar correctamente el valor de result
			result = false;
			#Ifdef TARGET_GLULX;

			#Ifdef USE_DAMUSIX;
			if (volume == 0) {
				volume = 100;
			}
			Damusix.TocarV(sound, volume);
			#Endif; ! USE_DAMUSIX;

			#Ifdef USE_VORPLE;
			result = self.fade_in(sound);
			#Endif; ! USE_VORPLE;

			#Endif; ! TARGET_GLULX;
			sound = volume = 0; ! (por evitar alertas del compilador)
 			return result;
		],
		!!----------------------------------------------------------------------
		!! Espera una pulsación de tecla del usuario antes de continuar.
		!!
		!!	@param {string} [txt=0] - Mensaje opcional. Si se especifica uno la
		!!		rutina lo imprime con el estilo de texto reservado para
		!!		mensajes de la aplicación seguido de un salto de línea, antes
		!!		de iniciar la espera de pulsación de tecla
		!!	@param {integer} [delay=0] - Si 'delay' >= 0 la obra continúa con
		!!		la ejecución tras esperar una cantidad 'delay' de décimas de
		!!		segundo, aún si el usuario no ha pulsado ninguna tecla
		!!	@returns {char} Caracter introducido por el usuario
		!!	@version 2019/03/21
		!!----------------------------------------------------------------------
		press_any_key [ txt delay
			previous_style result;
			if (txt ~= 0 && metaclass(txt) == String) {
				previous_style = self.set_text_style(TEXT_STYLE_PARSER);
				print (string) TEXT_STYLE_PARSER_PREFIX;
				print (string) txt;
				print (string) TEXT_STYLE_PARSER_SUFIX;
				self.set_text_style(previous_style);
				new_line;
			}
			#Ifdef USE_DAMUSIX;
			if (Damusix.EnFade()) delay = 0;
			#Endif; ! USE_DAMUSIX;
			if (delay > 0) result = KeyDelay(delay);
			else result = KeyCharPrimitive();
			return result;
		],
		!!----------------------------------------------------------------------
		!! Imprime el separador "* * *" con estilo monoespaciado y seguido de
		!! un salto de línea. Si se compila para plataformas de escritorio se
		!! centra en pantalla, en otro caso se alinea a la izquierda.
		!!
		!!	@returns {boolean} Verdadero
		!!	@dependency arrays.h
		!!	@version 2019/06/22
		!!----------------------------------------------------------------------
		print_horizontal_rule [
			length previous_style txt;
			length = 0;
			txt = "* * *";
			previous_style = self.set_text_style(TEXT_STYLE_MONOSPACED);
			#Ifdef VERSION_DESKTOP;
			PrintToBuffer(utility_array_a, INPUT_BUFFER_LEN, txt);
			length = utility_array_a->(WORDSIZE-1);
			spaces (ScreenWidth()-1-length) / 2;
			PrintCharacterArray(utility_array_a);
			#Ifnot; ! VERSION_WEB_MOBILE;
			print (string) txt;
			#Endif; ! VERSION_
			self.set_text_style(previous_style);
			new_line;
			return true;
		],
		!!----------------------------------------------------------------------
		!! Lee desde un fichero de texto externo los parámetros de
		!! configuración de la obra.
		!!
		!!	@param {string} file_name - Nombre del fichero de texto del que se
		!!		leen los parámetros de configuración
		!!	@returns {boolean} Verdadero si el fichero se lee con éxito. Falso
		!!		en caso contrario
		!!	@version 2019/06/24
		!!----------------------------------------------------------------------
		!! FIXME - comprobar funcionalidades de fichero externo
		read_configuration_file [ file_name
			file_ref str ch i a b c d e f g h;
			#Ifdef TARGET_GLULX;
			a = b = c = d = -1;
			!!	glk_fileref_create_by_name(
			!!		fileusage_Data + fileusage_BinaryMode,
			!!		ChangeAnyToCString(file_name), 0);
			file_ref = glk($0061, $00+$000, ChangeAnyToCString(file_name), 0);
			if (file_ref ~= 0) {
				!!	glk_stream_open_file(fileref, filemode_Read, 0);
				str = glk($0042, file_ref, $02, 0);
				glk($0063, file_ref); ! glk_fileref_destroy
				for (i = 1 : i <= 8 : i++) {
					do ch = glk($0090, str); ! glk_get_char_stream
					until ((ch == null) || (ch >= 48 && ch <= 57));
					if (ch == null) break;
					switch (i) {
						1:	a = (ch-48);
						2:	b = (ch-48);
						3:	c = (ch-48);
						4:	d = (ch-48);
						5:	e = (ch-48);
						6:	f = (ch-48);
						7:	g = (ch-48);
						8:	h = (ch-48);
					}
					do ch = glk($0090, str); ! glk_get_char_stream
					until ((ch == null) || (ch == 10)); ! (hasta nueva línea)
				}
				!! Cierra el archivo:
				glk($0044, str, 0); ! glk_stream_close
				!! Comprueba errores:
				if (a < 0 || a > 1) return false;
				if (b < 0 || b > 1) return false;
				if (c < 0 || c > 1) return false;
				if (d < 0 || d > 1) return false;
				if (e < 0 || e > 7) return false;
				if (f < 0 || f > 7) return false;
				if (g < 0 || g > 7) return false;
				if (h < 0 || h > 7) return false;
				!! Transforma los códigos de estilo a los valores reales:
				switch (e) {
					1:	e = TEXT_STYLE_STRESSED;
					2:	e = TEXT_STYLE_NOTE;
					3:	e = TEXT_STYLE_IMPORTANT;
					4:	e = TEXT_STYLE_HEADER;
					5:	e = TEXT_STYLE_MONOSPACED;
					6:	e = TEXT_STYLE_QUOTE;
					7:	e = TEXT_STYLE_USER1;
					default: e = TEXT_STYLE_UPRIGHT;
				}
				switch (f) {
					1:	f = TEXT_STYLE_STRESSED;
					2:	f = TEXT_STYLE_NOTE;
					3:	f = TEXT_STYLE_IMPORTANT;
					4:	f = TEXT_STYLE_HEADER;
					5:	f = TEXT_STYLE_MONOSPACED;
					6:	f = TEXT_STYLE_QUOTE;
					7:	f = TEXT_STYLE_USER1;
					default: f = TEXT_STYLE_UPRIGHT;
				}
				switch (g) {
					1:	g = TEXT_STYLE_STRESSED;
					2:	g = TEXT_STYLE_NOTE;
					3:	g = TEXT_STYLE_IMPORTANT;
					4:	g = TEXT_STYLE_HEADER;
					5:	g = TEXT_STYLE_MONOSPACED;
					6:	g = TEXT_STYLE_QUOTE;
					7:	g = TEXT_STYLE_USER1;
					default: g = TEXT_STYLE_UPRIGHT;
				}
				switch (h) {
					1:	h = TEXT_STYLE_STRESSED;
					2:	h = TEXT_STYLE_NOTE;
					3:	h = TEXT_STYLE_IMPORTANT;
					4:	h = TEXT_STYLE_HEADER;
					5:	h = TEXT_STYLE_MONOSPACED;
					6:	h = TEXT_STYLE_QUOTE;
					7:	h = TEXT_STYLE_USER1;
					default: h = TEXT_STYLE_UPRIGHT;
				}
				!! Establece los parámetros de configuración y retorna:
				self.set_hyperlinks_status(1, a);
				self.set_hyperlinks_status(2, b);
				self.set_hyperlinks_status(3, c);
				self.set_hyperlinks_status(4, d);
				self.set_highlight_style(1, e);
				self.set_highlight_style(2, f);
				self.set_highlight_style(3, g);
				self.set_highlight_style(4, h);
				return true;
			}
			#Ifnot; ! TARGET_ZCODE;
			!! (Por evitar alertas del compilador)
			file_name = file_ref+str+ch+i+a+b+c+d+e+f+g+h;
			#Endif; ! TARGET_

			return false;
		],
		!!----------------------------------------------------------------------
		!! Reestablece el modelo del mundo a su estado inicial.
		!!
		!!	@returns {boolean} Verdadero
		!!	@version 2019/10/31
		!!----------------------------------------------------------------------
		restart [
			obj;
			objectloop(obj ofclass Thing) {
				give obj ~described;
				give obj ~general;
				give obj ~moved;
				obj.state = 0;
			}
			objectloop(obj ofclass Room) {
				give obj ~general;
				give obj ~visited;
			}
			return true;
		],
		!!----------------------------------------------------------------------
		!! Establece el modo de navegación.
		!!
		!!	@param {boolean} mode - Indica si la navegación se lleva a cabo a
		!!		través de la brújula (si 'mode' es verdadero) o no (si 'mode'
		!!		es falso)
		!!	@returns {boolean} Modo de navegación reemplazado
		!!	@version 2019/09/14
		!!----------------------------------------------------------------------
		set_compass_mode [ mode
			result;
			result = self.compass_mode;
			self.compass_mode = mode;
			return result;
		],
		!!----------------------------------------------------------------------
		!! Establece el valor de la flexión gramatical utilizada por la obra.
		!!
		!!	@param {integer} new_grammatical_inflection - Código de la nueva
		!!		flexión gramatical [1-9]
		!!	@returns {integer} Código de la flexión gramatical reemplazada
		!!	@version 1.0
		!!----------------------------------------------------------------------
		set_grammatical_inflection [ new_grammatical_inflection
			result;
			result = 2; ! (por defecto)
			#Ifdef USE_SPANISH_LM;
			result = _grammatical_inflection;
			SetGrammaticalInflection(new_grammatical_inflection);
			#Endif; ! USE_SPANISH_LM;
			new_grammatical_inflection = 0; ! (por evitar alertas del compil.)
			return result;
		],
		!!----------------------------------------------------------------------
		!! Establece el estilo de texto de las palabras destacadas para el
		!! tipo de objeto pasado como parámetro.
		!!
		!! El sistema de palabras destacadas es dependiente del sistema de
		!! hipervínculos, de manera que los estilos disponibles en un momento
		!! dado dependen del estado de los hipervínculos para ese tipo de
		!! objeto. Si se intenta establecer un estilo de texto que no es
		!! compatible con el estado de los hipervínculos, la rutina asigna
		!! automáticamente el siguiente estilo disponible.
		!!
		!!	@param {integer} object_type - Código numérico del tipo de objeto
		!!		para el que se pretende modificar el estilo de texto resaltado
		!!	@param {integer} text_style - Código numérico del nuevo estilo de
		!!		texto resaltado que se asigna al tipo de objeto 'object_type'
		!!	@returns {integer} Código numérico del estilo de texto resaltado
		!!		que se había estado utilizando previamente para los objetos del
		!!		tipo 'object_type'. -1 si 'object_type' no es un código válido
		!!	@date 2019/06/24
		!!----------------------------------------------------------------------
		set_highlight_style [ object_type text_style
			result status;
			!! Inicializaciones del método:
			if (object_type < 1 || object_type > 4) {
				return -1;
			}
			result = self.get_highlight_style(object_type);
			status = self.get_hyperlinks_status(object_type);
			!! Modifica el estilo de texto en función del estado calculado:
			if (text_style == TEXT_STYLE_NOTE or TEXT_STYLE_QUOTE
				&& status) {
				!! FIXME
				!! text_style = TEXT_STYLE_USER1;
			}
			!! Establece el estilo de texto y retorna el estilo previo:
			if ((object_type-1) < (self.#highlight_styles)/WORDSIZE) {
				self.&highlight_styles-->(object_type-1) = text_style;
			}
			return result;
		],
		!!----------------------------------------------------------------------
		!! Establece el estado de los hipervínculos para el tipo de objeto
		!! pasado como parámetro.
		!!
		!!	@param {integer} object_type - Código numérico del tipo de objeto
		!!		para el que se pretende modificar el estado de los
		!!		hipervínculos
		!!	@param {boolean} status - Estado (activado/desactivado) que se
		!!		asigna a los hipervínculos asociados al tipo de objeto
		!!		'object_type'
		!!	@returns {boolean} Estado de los hipervínculos que estaba
		!!		establecido previamente para los objetos de tipo 'object_type'
		!!	@version 1.0
		!!----------------------------------------------------------------------
		set_hyperlinks_status [ object_type status
			result highlight;
			!! Establece el estado de los hipervínculos para 'object_type':
			result = self.get_hyperlinks_status(object_type);
			if ((object_type-1) < (self.#hyperlinks_status)/WORDSIZE) {
				self.&hyperlinks_status-->(object_type-1) = status;
			}
			!! Actualiza el estilo de texto resaltado:
			highlight = self.get_highlight_style(object_type);
			self.set_highlight_style(object_type, highlight);
			!! Retorna el estado previo:
			return result;
		],
		!!----------------------------------------------------------------------
		!! Establece la alineación de los contenidos de la barra de estado.
		!!
		!!	@param {integer} alignment - Código numérico que representa la
		!!		alineación: {0 - izquierda; 1 - centro; 2 - derecha}
		!!	@returns {boolean} Verdadero si se está utilizando una barra de
		!!		estado modificable. Falso en caso contrario
		!!	@version 2019/06/18
		!!----------------------------------------------------------------------
		set_status_bar_alignment [ alignment
			result;
			#Ifdef USE_GWINDOWS;
			StatusBar.set_alignment(alignment);
			result = true;
			#Endif; ! USE_GWINDOWS;
			return result;
		],
		!!----------------------------------------------------------------------
		!! Establece los contenidos de la barra de estado.
		!!
		!!	@param {String} contents - Cadena de texto que se desea imprimir en
		!!		la barra de estado. 0 si se desea imprimir el nombre de la
		!!		localidad actual del usuario
		!!	@returns {boolean} Verdadero si se está utilizando una barra de
		!!		estado modificable. Falso en caso contrario
		!!	@version 2019/06/18
		!!----------------------------------------------------------------------
		set_status_bar_contents [ contents
			result;
			#Ifdef USE_GWINDOWS;
			StatusBar.set_contents(contents);
			result = true;
			#Endif; ! USE_GWINDOWS;
			return result;
		],
		!!----------------------------------------------------------------------
		!! Establece el estilo de texto utilizado por la obra.
		!!
		!!	@param {integer} style - Código numérico [1-10] del nuevo estilo
		!!		de texto
		!!	@returns {integer} Código numérico del estilo de texto reemplazado
		!!	@version 2.0
		!!----------------------------------------------------------------------
		set_text_style [ style
			result;
			result = 0; ! (por defecto)
			#Ifdef TEXT_STYLES;
			result = SetTextStyle(style);
			#Endif; ! TEXT_STYLES;
			style = 0; ! (por evitar alertas del compilador)
			return result;
		],
		!!----------------------------------------------------------------------
		!! Imprime el pronombre nominativo correcto correspondiente al objeto
		!! pasado como parámetro.
		!!
		!!	@param {Object} obj - Objeto del que se pretende imprimir su
		!!		pronombre nominativo
		!!	@param {boolean} [capitalized=false] - Si es verdadero, imprime el
		!!		pronombre con la primera letra en mayúscula
		!!	@returns {boolean} Falso si el objeto pasado como parámetro no es
		!!		un objeto. Verdadero en caso contrario
		!!	@version 2.1
		!!----------------------------------------------------------------------
		spanish_nominative_pronoun [ obj capitalized;
			if (metaclass(obj) == Object) {
				switch (GetGNAOfObject(obj)) {
					0, 6:
						if (capitalized) print "Él";
						else print "él";
					1, 7:
						if (capitalized) print "Ella";
						else print "ella";
					2, 8:
						if (capitalized) print "Ello";
						else print "ello";
					3, 9:
						if (capitalized) print "Ellos";
						else print "ellos";
					4, 10:
						if (capitalized) print "Ellas";
						else print "ellas";
					5, 11:
						if (capitalized) print "Ellos";
						else print "ellos";
				}
				return true;
			}
			return false;
		],
		!!----------------------------------------------------------------------
		!! Imprime una dirección web.
		!!
		!!	@param {string} website - Dirección web
		!!	@returns {boolean} Verdadero
		!!	@version 1.0
		!!----------------------------------------------------------------------
		website_hyperlink [ txt;
			#Ifdef USE_VORPLE;
			if (isVorpleSupported()) VorpleLinkWebsiteText(txt, txt);
			else print (stressed) txt;
			#Ifnot;
			print (stressed) txt;
			#Endif; ! USE_VORPLE;
			return true;
		],
		!!----------------------------------------------------------------------
		!! Guarda en un fichero de texto externo los parámetros de
		!! configuración de la aplicación.
		!!
		!!	@param {string} file_name - Nombre del fichero de texto en que se
		!!		escriben los parámetros de configuración
		!!	@returns {boolean} Verdadero si el fichero se escribe con éxito.
		!!		Falso en caso contrario
		!!	@version 2019/06/24
		!!----------------------------------------------------------------------
		write_configuration_file [ file_name
			file_ref str i temp_txt temp_code;
			!! FIXME - comprobar que el intérprete soporte la lectura/escritura
			#Ifdef TARGET_GLULX;
			!!	glk_fileref_create_by_name(
			!!		fileusage_Data + fileusage_BinaryMode,
			!!		ChangeAnyToCString(file_name), 0);
			file_ref = glk($0061, $00+$000, ChangeAnyToCString(file_name), 0);
			if (file_ref ~= 0) {
				!!	glk_stream_open_file(fileref, filemode_Write, 0);
				str = glk($0042, file_ref, $01, 0);
				glk($0063, file_ref); ! glk_fileref_destroy
				glk($0047, str); ! glk_stream_set_current
				!! Escritura en fichero de los parámetros de configuración:
				for (i = 1 : i <= 4 : i++) {
					switch (i) {
						1:	temp_txt = "objetos normales";
						2:	temp_txt = "objetos destacados";
						3:	temp_txt = "direcciones";
						4:	temp_txt = "temas de conversación";
					}
					print self.get_hyperlinks_status(i), " # Hipervínculos
					asociados a ", (string) temp_txt, " {0:no, 1:si}^";
				}
				for (i = 1 : i <= 4 : i++) {
					switch (i) {
						1:	temp_txt = "objetos normales";
						2:	temp_txt = "objetos destacados";
						3:	temp_txt = "direcciones";
						4:	temp_txt = "temas de conversación";
					}
					switch (self.get_highlight_style(i)) {
						TEXT_STYLE_UPRIGHT:		temp_code = 0;
						TEXT_STYLE_STRESSED:	temp_code = 1;
						TEXT_STYLE_NOTE:		temp_code = 2;
						TEXT_STYLE_IMPORTANT:	temp_code = 3;
						TEXT_STYLE_HEADER:		temp_code = 4;
						TEXT_STYLE_MONOSPACED:	temp_code = 5;
						TEXT_STYLE_QUOTE:	temp_code = 6;
						TEXT_STYLE_USER1:		temp_code = 7;
					}
					print temp_code, " # Estilo de texto de ",
					(string) temp_txt, " [0-7]^";
				}
				!! Cierra el archivo y termina la operación:
				glk($002F, gg_mainwin); ! glk_set_window
				glk($0044, str, 0); ! glk_stream_close
				return true;
			}
			#Ifnot; ! TARGET_ZCODE;
			!! (Por evitar alertas del compilador)
			file_name = file_ref + str + i + temp_txt + temp_code;
			#Endif; ! TARGET_

			return false;
		],
 private
		!!----------------------------------------------------------------------
		!! ATRIBUTOS PRIVADOS
		!!----------------------------------------------------------------------
		!! Navegación a través de los puntos cardinales:
		compass_mode false,
		!! Estilos de texto resaltado:
		highlight_styles 0 0 0 0,
		!! Estados de los hipervínculos:
		hyperlinks_status 0 0 0 0,
		!!----------------------------------------------------------------------
		!! MÉTODOS PRIVADOS
		!!----------------------------------------------------------------------
		!! Imprime el nombre corto de un objeto/una cadena de caracteres dada:
		print_object_short_name [ obj;
			if (metaclass(obj) == String) {
				print (string) obj;
				jump shortNamePrinted;
			}
			#Ifdef LanguagePrintShortName;
			if (LanguagePrintShortName(obj)) {
				jump shortNamePrinted;
			}
			#Endif; ! LanguagePrintShortName;
			if (indef_mode && obj.&short_name_indef ~= 0
				&& PrintOrRun(obj, short_name_indef, 1) ~= 0) {
				jump shortNamePrinted;
			}
			if (obj.&short_name ~= 0 && PrintOrRun(obj, short_name, 1) ~= 0) {
				jump shortNamePrinted;
			}
			print (object) obj;
			.shortNamePrinted;
			return true;
		],
;
