

!!==============================================================================
!!
!!	KICKSTART
!!	Definición de clases y atributos
!!
!!==============================================================================
!!
!!	Archivo:		kickstart_classes.inf
!!	Autor(es):		J. Francisco Martín <jfm.lisaso@gmail.com>
!!	Idioma:			ES (Español)
!!	Sistema:		Inform-INFSP 6
!!	Plataforma:		Máquina-Z/Glulx
!!	Versión:		0.0
!!	Fecha:			2019/MM/DD
!!
!!------------------------------------------------------------------------------
!!
!!	Este archivo forma parte de la ficción interactiva KICKSTART.
!!
!!	KICKSTART es software libre: usted puede redistribuirlo y/o
!!	modificarlo bajo los términos de la Licencia Pública General
!!	GNU publicada por la Fundación para el Software Libre, ya
!!	sea la versión 3 de la Licencia, o (a su elección) cualquier
!!	versión posterior.
!!
!!	KICKSTART se distribuye con la esperanza de que sea útil,
!!	pero SIN GARANTÍA ALGUNA; ni siquiera la garantía implícita
!!	MERCANTIL o de APTITUD PARA UN PROPÓSITO DETERMINADO.
!!	Consulte los detalles de la Licencia Pública General GNU
!!	para más información.
!!
!!	Debería haber recibido una copia de la Licencia Pública
!!	General GNU junto a KICKSTART. En caso contrario, consulte
!!	<http://www.gnu.org/licenses/>.
!!
!!	Copyright (c) 2019, J. Francisco Martín
!!
!!------------------------------------------------------------------------------
!!
!!	TABLA DE CONTENIDOS
!!
!!	<>	Receptacle
!!	<>	SmartEnterable
!!	<>	Thing
!!	<>	Thing:Atrezzo
!!	<>	Thing:Atrezzo:AdjacentRoom
!!	<>	Thing:Atrezzo:Background
!!	<>	Thing:Atrezzo:Room
!!	<>	Thing:Atrezzo:Room:Indoors
!!	<>	Thing:Atrezzo:Room:Outdoors
!!	<>	Thing:Character
!!	<>	Thing:Item
!!	<>	Thing:Item:Clothes
!!	<>	Thing:Item:HeavyItem
!!
!!------------------------------------------------------------------------------
!!
!!	NOTA SOBRE LAS PROPIEDADES DE CLASE
!!
!!	Hay rutinas como 'before' o 'react_before' que son propiedades no aditivas,
!!	es decir, si se crea una clase que defina un comportamiento específico para
!!	una de estas propiedades, y a continuación se crea un objeto como instancia
!!	de esta clase de forma que también él defina su propia versión de alguna de
!!	estas propiedades no aditivas, las rutinas del objeto "sobreescribirán"
!!	completamente aquellas de la clase. Dicho de otra manera, si el objeto
!!	define las suyas propias, las rutinas 'before' y 'react_before' de la clase
!!	de la que es instancia NO SERÁN INVOCADAS en ningún momento. Sin embargo,
!!	se puede hacer una llamada explícita a la rutina de la clase desde la
!!	rutina del objeto. A continuación se especifica cómo un objeto 'objectName'
!!	invocaría a la rutina 'react_before' de una superclase 'className' de su
!!	jerarquía de clases:
!!
!!		objectName.className::react_before();
!!
!!------------------------------------------------------------------------------

!!------------------------------------------------------------------------------
!! Receptacle
!!------------------------------------------------------------------------------
!! 'Receptacle' define contenedores o soportes con límites de capacidad (en
!! cantidad, tamaño, volumen y peso). Al tratar de introducir cualquier objeto
!! en un 'Receptacle' se ejecutan automáticamente las comprobaciones oportunas
!! para determinar si el contenedor tiene o no capacidad suficiente para
!! albergar el nuevo objeto.
!!
!!	@dependency SpanishLM.h
!!	@version 2019/07/15
!!------------------------------------------------------------------------------
Class	Receptacle
 with	before [;
			Receive:
				switch (Utils.check_object_capacity(self, noun)) {
					!! Superado el límite en el número de objetos:
					-1:
						print "En ", (the) self, " ya no ";
						switch (Utils.get_grammatical_inflection()) {
							FIRST_PERSON_PRESENT,
							SECOND_PERSON_PRESENT,
							THIRD_PERSON_PRESENT:
								print "cabe";
							FIRST_PERSON_PAST,
							SECOND_PERSON_PAST,
							THIRD_PERSON_PAST:
								print "cabía";
							FIRST_PERSON_FUTURE,
							SECOND_PERSON_FUTURE,
							THIRD_PERSON_FUTURE:
								print "cabrá";
						}
						" nada más.";
					!! Superado el límite de tamaño:
					-2:
						print (The) noun, " ";
						switch (Utils.get_grammatical_inflection()) {
							FIRST_PERSON_PRESENT,
							SECOND_PERSON_PRESENT,
							THIRD_PERSON_PRESENT:
								print (es) noun;
							FIRST_PERSON_PAST,
							SECOND_PERSON_PAST,
							THIRD_PERSON_PAST:
								print "era", (n) noun;
							FIRST_PERSON_FUTURE,
							SECOND_PERSON_FUTURE,
							THIRD_PERSON_FUTURE:
								print "será", (n) noun;
						}
						print " demasiado grande", (s) noun, " para";
						if (self has supporter) {
							print " colocarl", (o) noun, " sobre";
						} else if (self has container) {
							print " meterl", (o) noun, " en";
						}
						!! XXX - El mensaje es adecuado aunque el contenedor
						!! esté mal definido y no tenga las propiedades
						!! 'supporter' o 'container'.
						" ", (the) self, ".";
					!! Superado el límite de volumen:
					-3:
						print (The) noun, " ";
						switch (Utils.get_grammatical_inflection()) {
							FIRST_PERSON_PRESENT,
							SECOND_PERSON_PRESENT,
							THIRD_PERSON_PRESENT:
								print (es) noun;
							FIRST_PERSON_PAST,
							SECOND_PERSON_PAST,
							THIRD_PERSON_PAST:
								print "era", (n) noun;
							FIRST_PERSON_FUTURE,
							SECOND_PERSON_FUTURE,
							THIRD_PERSON_FUTURE:
								print "será", (n) noun;
						}
						print " demasiado voluminos", (o) noun, " para";
						if (self has supporter) {
							print " colocarl", (o) noun, " sobre";
						} else if (self has container) {
							print " meterl", (o) noun, " en";
						}
						" ", (the) self, ".";
					!! Superado el límite de volumen agregado:
					-4:
						print "No ";
						switch (Utils.get_grammatical_inflection()) {
							FIRST_PERSON_PRESENT,
							SECOND_PERSON_PRESENT,
							THIRD_PERSON_PRESENT:
								print "hay";
							FIRST_PERSON_PAST,
							SECOND_PERSON_PAST,
							THIRD_PERSON_PAST:
								print "había";
							FIRST_PERSON_FUTURE,
							SECOND_PERSON_FUTURE,
							THIRD_PERSON_FUTURE:
								print "habrá";
						}
						print " hueco suficiente en ", (the) self, " para";
						if (self has supporter) {
							print " colocar";
						} else if (self has container) {
							print " meter";
						}
						" ", (the) noun, ".";
					!! Superado el límite de peso:
					-5:
						print (The) noun, " ";
						switch (Utils.get_grammatical_inflection()) {
							FIRST_PERSON_PRESENT,
							SECOND_PERSON_PRESENT,
							THIRD_PERSON_PRESENT:
								print (es) noun;
							FIRST_PERSON_PAST,
							SECOND_PERSON_PAST,
							THIRD_PERSON_PAST:
								print "era", (n) noun;
							FIRST_PERSON_FUTURE,
							SECOND_PERSON_FUTURE,
							THIRD_PERSON_FUTURE:
								print "será", (n) noun;
						}
						print " demasiado pesad", (o) noun, " para";
						if (self has supporter) {
							print " colocarl", (o) noun, " sobre";
						} else if (self has container) {
							print " meterl", (o) noun, " en";
						}
						" ", (the) self, ".";
					!! Superado el límite de peso agregado:
					-6:
						print (The) self, " no ";
						switch (Utils.get_grammatical_inflection()) {
							FIRST_PERSON_PRESENT,
							SECOND_PERSON_PRESENT,
							THIRD_PERSON_PRESENT:
								print "puede", (n) self;
							FIRST_PERSON_PAST,
							SECOND_PERSON_PAST,
							THIRD_PERSON_PAST:
								print "podía", (n) self;
							FIRST_PERSON_FUTURE,
							SECOND_PERSON_FUTURE,
							THIRD_PERSON_FUTURE:
								print "podrá", (n) self;
						}
						" soportar tanto peso.";
				}
		],
;

!!------------------------------------------------------------------------------
!! SmartEnterable
!!------------------------------------------------------------------------------
!! Representa un objeto al que el PC puede entrar o subirse encima, con una
!! serie de comportamientos automáticos que afectan al PC si trata de realizar
!! acciones desde dentro de un objeto de esta clase.
!!
!!	@dependency AdjacentRoom
!!	@version 2019/09/15
!!------------------------------------------------------------------------------
Class	SmartEnterable
 has	enterable,
 with	react_before [
			obj;
			!! GROUP #2: Usually work, given the right circumstances:
			Close,
			Open:
				if ((parent(player) == self)
					&& (self.out_of_reach(noun) && noun has openable)) {
					<Exit self>;
					new_line;
				}
			Disrobe:
				if ((parent(player) == self)
					&& (noun has clothing && noun has worn)) {
					<Exit self>;
					new_line;
				}
			Drop:
				if ((parent(player) == self)
					&& (noun ~= player && IndirectlyContains(player, noun))) {
					switch (metaclass(self.drop_on_object)) {
						Object:
							obj = self.drop_on_object;
						Routine:
							obj = self.drop_on_object();
						default:
							obj = self;
					}
					move noun to obj;
					if (keep_silent == 0) print "Dejad", (o) noun, ".^";
					return true;
				}
			Eat:
				if ((parent(player) == self)
					&& (self.out_of_reach(noun) && noun has edible)) {
					<Exit self>;
					new_line;
				}
			Empty,
			Remove,
			Search,
			Take:
				if ((parent(player) == self)
					&& (self.out_of_reach(noun))) {
					<Exit self>;
					new_line;
				}
			EmptyT:
				if (parent(player) == self) {
					if (ObjectIsUntouchable(noun, 1)) {
						return false;
					}
					if (self.out_of_reach(second)) {
						<Exit self>;
						new_line;
					}
				}
			Go:
				if ((parent(player) == self)
					&& (noun ofclass CompassDirection
					|| noun ofclass AdjacentRoom)) {
					<Exit self>;
					new_line;
				}
			Insert,
			PutOn:
				if (player(player) == self) {
					if (second == d_obj) {
						<<Drop noun>>;
					}
					if (self.out_of_reach(second)) {
						<Exit self>;
						new_line;
					}
				}
			Lock,
			Unlock:
				if ((parent(player) == self)
					&& (self.out_of_reach(noun) && self has lockable)) {
					<Exit self>;
					new_line;
				}
			SwitchOff,
			SwitchOn:
				if ((parent(player) == self)
					&& (self.out_of_reach(noun) && self has switchable)) {
					<Exit self>;
					new_line;
				}
			Wear:
				if ((parent(player) == self)
					&& (noun has clothing && noun hasnt worn)) {
					<Exit self>;
					new_line;
				}
			!! GROUP #3: Output a message and stop at the "before" stage:
			Attack,
			Blow,
			LookUnder,
			Smell,
			Squeeze,
			Taste,
			Touch:
				if ((parent(player) == self)
					&& (self.out_of_reach(noun))) {
					<Exit self>;
					new_line;
				}
			Climb:
				if ((parent(player) == self)
					&& (self.out_of_reach(noun) && noun has enterable)) {
					<Exit self>;
					new_line;
				}
			Jump:
				if ((parent(player) == self)
					&& (noun has supporter)) {
					<<Exit self>>;
				}
			Pull,
			Push,
			PushDir,
			Turn:
				if ((parent(player) == self)
					&& (self.out_of_reach(noun)
					&& noun has scenery or static)) {
					<Exit self>;
					new_line;
				}
			Swing:
				if ((parent(player) == self)
					&& (self has supporter && noun == nothing)) {
					<<Swing self>>;
				}
			GoDown:
				if ((parent(player) == self)
					&& (self has supporter && noun == nothing)) {
					<<Exit self>>;
				}
			StandUp:
				if ((parent(player) == self)
					&& (self has supporter && noun == nothing or self)) {
					<<Exit self>>;
				}
		],
		!! Objeto destino de la acción ##Drop estando en el SmartEnterable:
		drop_on_object 0,
		!! Objetos al alcance adicionales desde el SmartEnterable:
		reach_objects 0,
 private
		!! Indica si el objeto pasado como parámetro se encuentra fuera de
		!! alcance desde el SmartEnterable. Retorna verdadero si el objeto está
		!! fuera de alcance, falso en caso contrario. [Código adaptado de la
		!! librería OutOfRch.h v2.00, de Marnie Parker <doeadeer3@aol.com>].
		out_of_reach [ obj
			top x y i;
			!! Se comprueba si el objeto se encuentra fuera de la localidad o
			!! en el interior de un contenedor cerrado:
			if (ObjectIsUntouchable(obj, true)) return false;
			!! Se comrpueba si el objeto se encuentra en el jugador o en el
			!! propio SmartEnterable:
			if (IndirectlyContains(player, obj)) return false;
			if (IndirectlyContains(self, obj)) return false;
			!! Se comprueba si el objeto es o se encuentra contenido en alguno
			!! de los reach_objects definidas:
			top = Utils.get_top_holder(obj);
			if (metaclass(self.&reach_objects-->0) == Routine) {
				x = self.reach_objects();
				if (x == top) return false;
			}
			if (metaclass(self.&reach_objects-->0) == Object or Class) {
				y = self.#reach_objects;
				for (i = 0 : i < (y/2) : i++) {
					x = self.&reach_objects-->i;
					if (x == top) return false;
				}
			}
			!! El objeto se encuentra fuera del alcance:
			return true;
		],
;

!!------------------------------------------------------------------------------
!! Thing
!!------------------------------------------------------------------------------
!! Representa un objeto dentro del modelo del mundo, con un tamaño, volumen y
!! peso específicos, así como diferentes valores de capacidad asociados a su
!! potencial como contenedor para otros objetos. Está ideada como una clase
!! abstracta sobre la que definir el resto de subclases más concretas de
!! objetos con los que modelar el mundo del relato.
!!
!!	@dependency SpanishLM.h
!!	@version 2019/09/20
!!------------------------------------------------------------------------------
Class	Thing
 with	capacity_size	-1,	! Capacidad total: en cuanto a tamaño
		capacity_volume	-1,	! Capacidad total: en cuanto a volumen
		capacity_weight	-1,	! Capacidad total: en cuanto a peso
		size	0,			! Tamaño
		state	0,			! Estado
		volume	0,			! Volumen
		weight	0,			! Peso
		description [;
			switch (Utils.get_grammatical_inflection()) {
				FIRST_PERSON_PRESENT:
					if (IsPluralNoun(player)) print "No vemos";
					else print "No veo";
				SECOND_PERSON_PRESENT:
					if (IsPluralNoun(player)) print "No veis";
					else print "No ves";
				THIRD_PERSON_PRESENT:
					if (IsPluralNoun(player)) print "No ven";
					else print "No ve";
				FIRST_PERSON_PAST:
					if (IsPluralNoun(player)) print "No vimos";
					else print "No vi";
				SECOND_PERSON_PAST:
					if (IsPluralNoun(player)) print "No visteis";
					else print "No viste";
				THIRD_PERSON_PAST:
					if (IsPluralNoun(player)) print "No vieron";
					else print "No vio";
				FIRST_PERSON_FUTURE:
					if (IsPluralNoun(player)) print "No veremos";
					else print "No veré";
				SECOND_PERSON_FUTURE:
					if (IsPluralNoun(player)) print "No veréis";
					else print "No verás";
				THIRD_PERSON_FUTURE:
					if (IsPluralNoun(player)) print "No verán";
					else print "No verá";
			}
			print " nada especial en ";
			Utils.spanish_nominative_pronoun(self);
			".";
		],
;

!!------------------------------------------------------------------------------
!! Thing:Atrezzo
!!------------------------------------------------------------------------------
!! Representa un objeto decorado dentro del modelo de mundo. Se le aplica las
!! propiedades 'oculto' (concealed) y 'estático' (static) definidas por la
!! librería Inform.
!!
!!	@dependency arrays.h
!!	@dependency SpanishLM.h
!!	@version 2019/09/19
!!------------------------------------------------------------------------------
Class	Atrezzo
 class	Thing
 has	concealed static,
 with	before [
			previous_style;
			!! Puesto que 'Atrezzo' se utiliza como superclase para definir
			!! localidades, la siguiente comprobación permite filtrar acciones
			!! sin objeto realizadas dentro de la localidad:
			if (noun ~= self) return false;
			Attack,
			Blow,
			Close,
			DefaultAction,
			Disrobe,
			Enter,
			Examine,
			Listen,
			Lock,
			Open,
			Read,
			Search,
			Smell,
			SwitchOn,
			SwitchOff,
			Unlock,
			Wear:
				return false;
			Climb:
				previous_style = Utils.set_text_style(TEXT_STYLE_PARSER);
				print (string) TEXT_STYLE_PARSER_PREFIX;
				PrefaceByArticle(self, 1, -1, 1); ! (El/La/Los/Las)
				PrintToBuffer(utility_array_a, INPUT_BUFFER_LEN, self);
				PrintCharacterArray(utility_array_a);
				print " no ", (es) self, " algo a lo que puedas trepar.";
				print (string) TEXT_STYLE_PARSER_SUFIX;
				Utils.set_text_style(previous_style);
				new_line;
				return true;
			Cut:
				previous_style = Utils.set_text_style(TEXT_STYLE_PARSER);
				print (string) TEXT_STYLE_PARSER_PREFIX;
				PrefaceByArticle(self, 1, -1, 1); ! (El/La/Los/Las)
				PrintToBuffer(utility_array_a, INPUT_BUFFER_LEN, self);
				PrintCharacterArray(utility_array_a);
				print " no ", (es) self, " algo que puedas cortar.";
				print (string) TEXT_STYLE_PARSER_SUFIX;
				Utils.set_text_style(previous_style);
				new_line;
				return true;
			Dig:
				previous_style = Utils.set_text_style(TEXT_STYLE_PARSER);
				print (string) TEXT_STYLE_PARSER_PREFIX;
				PrefaceByArticle(self, 1, -1, 1); ! (El/La/Los/Las)
				PrintToBuffer(utility_array_a, INPUT_BUFFER_LEN, self);
				PrintCharacterArray(utility_array_a);
				print " no ", (es) self, " algo en lo que puedas cavar.";
				print (string) TEXT_STYLE_PARSER_SUFIX;
				Utils.set_text_style(previous_style);
				new_line;
				return true;
			Drink:
				previous_style = Utils.set_text_style(TEXT_STYLE_PARSER);
				print (string) TEXT_STYLE_PARSER_PREFIX;
				PrefaceByArticle(self, 1, -1, 1); ! (El/La/Los/Las)
				PrintToBuffer(utility_array_a, INPUT_BUFFER_LEN, self);
				PrintCharacterArray(utility_array_a);
				print " no ", (es) self, " algo que puedas beber.";
				print (string) TEXT_STYLE_PARSER_SUFIX;
				Utils.set_text_style(previous_style);
				new_line;
				return true;
			Drop:
				switch (Utils.get_grammatical_inflection()) {
					FIRST_PERSON_PRESENT,
					SECOND_PERSON_PRESENT,
					THIRD_PERSON_PRESENT:
						"Ya está", (n) self, " ahí.";
					FIRST_PERSON_PAST,
					SECOND_PERSON_PAST,
					THIRD_PERSON_PAST:
						"Ya estaba", (n) self, " allí.";
					FIRST_PERSON_FUTURE,
					SECOND_PERSON_FUTURE,
					THIRD_PERSON_FUTURE:
						"Ya estará", (n) self, " allí.";
				}
			Eat,
			Taste:
				previous_style = Utils.set_text_style(TEXT_STYLE_PARSER);
				print (string) TEXT_STYLE_PARSER_PREFIX;
				PrefaceByArticle(self, 1, -1, 1); ! (El/La/Los/Las)
				PrintToBuffer(utility_array_a, INPUT_BUFFER_LEN, self);
				PrintCharacterArray(utility_array_a);
				print " no ", (es) self, " algo que puedas comer.";
				print (string) TEXT_STYLE_PARSER_SUFIX;
				Utils.set_text_style(previous_style);
				new_line;
				return true;
			Jump,
			JumpOver:
				previous_style = Utils.set_text_style(TEXT_STYLE_PARSER);
				print (string) TEXT_STYLE_PARSER_PREFIX;
				PrefaceByArticle(self, 1, -1, 1); ! (El/La/Los/Las)
				PrintToBuffer(utility_array_a, INPUT_BUFFER_LEN, self);
				PrintCharacterArray(utility_array_a);
				print " no ", (es) self, " algo sobre lo que puedas saltar.";
				print (string) TEXT_STYLE_PARSER_SUFIX;
				Utils.set_text_style(previous_style);
				new_line;
				return true;
			Pull,
			Push,
			PushDir,
			Take,
			Turn,
			Wave:
				previous_style = Utils.set_text_style(TEXT_STYLE_PARSER);
				print (string) TEXT_STYLE_PARSER_PREFIX;
				print "No puedes manipular ", (el_) noun;
				PrintToBuffer(utility_array_a, INPUT_BUFFER_LEN, noun);
				PrintCharacterArray(utility_array_a);
				print " de ese modo.";
				print (string) TEXT_STYLE_PARSER_SUFIX;
				Utils.set_text_style(previous_style);
				new_line;
				return true;
			default:
				previous_style = Utils.set_text_style(TEXT_STYLE_PARSER);
				print (string) TEXT_STYLE_PARSER_PREFIX;
				print "No puedes interactuar con ", (the) self, " de ese modo.";
				print (string) TEXT_STYLE_PARSER_SUFIX;
				Utils.set_text_style(previous_style);
				new_line;
				return true;
		],
;

!!------------------------------------------------------------------------------
!! Thing:Atrezzo:Background
!!------------------------------------------------------------------------------
!! Objetos de decorado con la interactividad más restringida; objetos lejanos,
!! objetos inmateriales, objetos de menor importancia…
!!
!!	@dependency arrays.h
!!	@dependency textStyles.h
!!	@version 2019/09/19
!!------------------------------------------------------------------------------
Class	Background
 class	Atrezzo
 with	before [
			previous_style;
			DefaultAction,
			Examine:
				return false;
			Attack,
			Blow,
			Enter,
			Listen,
			Search,
			Smell:
				previous_style = Utils.set_text_style(TEXT_STYLE_PARSER);
				print (string) TEXT_STYLE_PARSER_PREFIX;
				print "No puedes interactuar con ", (the) self, " de ese modo.";
				print (string) TEXT_STYLE_PARSER_SUFIX;
				Utils.set_text_style(previous_style);
				new_line;
				return true;
			Close,
			Lock:
				previous_style = Utils.set_text_style(TEXT_STYLE_PARSER);
				print (string) TEXT_STYLE_PARSER_PREFIX;
				PrefaceByArticle(self, 1, -1, 1); ! (El/La/Los/Las)
				PrintToBuffer(utility_array_a, INPUT_BUFFER_LEN, self);
				PrintCharacterArray(utility_array_a);
				print " no ", (es) self, " algo que puedas cerrar.";
				print (string) TEXT_STYLE_PARSER_SUFIX;
				Utils.set_text_style(previous_style);
				new_line;
				return true;
			Disrobe,
			Wear:
				previous_style = Utils.set_text_style(TEXT_STYLE_PARSER);
				print (string) TEXT_STYLE_PARSER_PREFIX;
				PrefaceByArticle(self, 1, -1, 1); ! (El/La/Los/Las)
				PrintToBuffer(utility_array_a, INPUT_BUFFER_LEN, self);
				PrintCharacterArray(utility_array_a);
				print " no ", (es) self, " algo con lo que te puedas vestir.";
				print (string) TEXT_STYLE_PARSER_SUFIX;
				Utils.set_text_style(previous_style);
				new_line;
				return true;
			Open,
			Unlock:
				previous_style = Utils.set_text_style(TEXT_STYLE_PARSER);
				print (string) TEXT_STYLE_PARSER_PREFIX;
				PrefaceByArticle(self, 1, -1, 1); ! (El/La/Los/Las)
				PrintToBuffer(utility_array_a, INPUT_BUFFER_LEN, self);
				PrintCharacterArray(utility_array_a);
				print " no ", (es) self, " algo que puedas abrir.";
				print (string) TEXT_STYLE_PARSER_SUFIX;
				Utils.set_text_style(previous_style);
				new_line;
				return true;
			SwitchOn:
				previous_style = Utils.set_text_style(TEXT_STYLE_PARSER);
				print (string) TEXT_STYLE_PARSER_PREFIX;
				PrefaceByArticle(self, 1, -1, 1); ! (El/La/Los/Las)
				PrintToBuffer(utility_array_a, INPUT_BUFFER_LEN, self);
				PrintCharacterArray(utility_array_a);
				print " no ", (es) self, " algo que puedas encender.";
				print (string) TEXT_STYLE_PARSER_SUFIX;
				Utils.set_text_style(previous_style);
				new_line;
				return true;
			SwitchOff:
				previous_style = Utils.set_text_style(TEXT_STYLE_PARSER);
				print (string) TEXT_STYLE_PARSER_PREFIX;
				PrefaceByArticle(self, 1, -1, 1); ! (El/La/Los/Las)
				PrintToBuffer(utility_array_a, INPUT_BUFFER_LEN, self);
				PrintCharacterArray(utility_array_a);
				print " no ", (es) self, " algo que puedas apagar.";
				print (string) TEXT_STYLE_PARSER_SUFIX;
				Utils.set_text_style(previous_style);
				new_line;
				return true;
		],
;

!!------------------------------------------------------------------------------
!! Thing:Atrezzo:AdjacentRoom
!!------------------------------------------------------------------------------
!! Representa un objeto dentro del modelo de mundo hacia el que el PC se puede
!! desplazar.
!!
!!	@dependency arrays.h
!!	@dependency textStyles.h
!!	@version 2019/06/17
!!------------------------------------------------------------------------------
Class	AdjacentRoom
 class	Atrezzo
 has	open,
 with	adjacent_room 0,
		before [
			obj;
			Enter,
			Go:
				if (self.adjacent_room ~= 0) {
					if (metaclass(self.adjacent_room) == Routine) {
						obj = self.adjacent_room();
					}
					if (metaclass(self.adjacent_room) == Object) {
						obj = self.adjacent_room;
					}
					new_line;
					PlayerTo(obj);
				} else {
					switch (Utils.get_grammatical_inflection()) {
						FIRST_PERSON_PRESENT:
							if (IsPluralNoun(player)) print "No podemos";
							else print "No puedo";
							print " llegar hasta ", (the) self, " desde aquí.";
						SECOND_PERSON_PRESENT:
							if (IsPluralNoun(player)) print "No podéis";
							else print "No puedes";
							print " llegar hasta ", (the) self, " desde aquí.";
						THIRD_PERSON_PRESENT:
							if (IsPluralNoun(player)) print "No pueden";
							else print "No puede";
							print " llegar hasta ", (the) self, " desde aquí.";
						FIRST_PERSON_PAST:
							if (IsPluralNoun(player)) print "No podíamos";
							else print "No podía";
							print " llegar hasta ", (the) self, " desde allí.";
						SECOND_PERSON_PAST:
							if (IsPluralNoun(player)) print "No podíais";
							else print "No podías";
							print " llegar hasta ", (the) self, " desde allí.";
						THIRD_PERSON_PAST:
							if (IsPluralNoun(player)) print "No podían";
							else print "No podía";
							print " llegar hasta ", (the) self, " desde allí.";
						FIRST_PERSON_FUTURE:
							if (IsPluralNoun(player)) print "No podremos";
							else print "No podré";
							print " llegar hasta ", (the) self, " desde allí.";
						SECOND_PERSON_FUTURE:
							if (IsPluralNoun(player)) print "No podréis";
							else print "No podrás";
							print " llegar hasta ", (the) self, " desde allí.";
						THIRD_PERSON_FUTURE:
							if (IsPluralNoun(player)) print "No podrán";
							else print "No podrá";
							print " llegar hasta ", (the) self, " desde allí.";
					}
					new_line;
				}
				return true;
		],
		description [;
			return L__M(##Look, 7, self);
		],
;

!!------------------------------------------------------------------------------
!! Thing:Atrezzo:Room
!!------------------------------------------------------------------------------
!! Representa un objeto localidad dentro del modelo de mundo.
!!
!!	@version 2019/09/19
!!------------------------------------------------------------------------------
Class	Room
 class	Atrezzo
 has	light,
 with	before [
			previous_style;
			if (noun ~= self) return false;
			Climb:
				previous_style = Utils.set_text_style(TEXT_STYLE_PARSER);
				print (string) TEXT_STYLE_PARSER_PREFIX;
				print "No ", (es) self, " algo a lo que puedas trepar.";
				print (string) TEXT_STYLE_PARSER_SUFIX;
				Utils.set_text_style(previous_style);
				new_line;
				return true;
			Cut:
				previous_style = Utils.set_text_style(TEXT_STYLE_PARSER);
				print (string) TEXT_STYLE_PARSER_PREFIX;
				print "No ", (es) self, " algo que puedas cortar.";
				print (string) TEXT_STYLE_PARSER_SUFIX;
				Utils.set_text_style(previous_style);
				new_line;
				return true;
   			DefaultAction,
   			Examine,
   			Search:
				<<Look>>;
   			Dig:
				return L__M(##Climb);
			Drink:
				previous_style = Utils.set_text_style(TEXT_STYLE_PARSER);
				print (string) TEXT_STYLE_PARSER_PREFIX;
				print "No ", (es) self, " algo que puedas beber.";
				print (string) TEXT_STYLE_PARSER_SUFIX;
				Utils.set_text_style(previous_style);
				new_line;
				return true;
			Eat,
			Taste:
				previous_style = Utils.set_text_style(TEXT_STYLE_PARSER);
				print (string) TEXT_STYLE_PARSER_PREFIX;
				print "No ", (es) self, " algo que puedas comer.";
				print (string) TEXT_STYLE_PARSER_SUFIX;
				Utils.set_text_style(previous_style);
				new_line;
				return true;
			Jump:
				return L__M(##Jump);
			JumpOver:
				previous_style = Utils.set_text_style(TEXT_STYLE_PARSER);
				print (string) TEXT_STYLE_PARSER_PREFIX;
				print "No ", (es) self, " algo sobre lo que puedas saltar.";
				print (string) TEXT_STYLE_PARSER_SUFIX;
				Utils.set_text_style(previous_style);
				new_line;
				return true;
			Pull,
			Push,
			PushDir,
			Take,
			Turn,
			Wave:
				previous_style = Utils.set_text_style(TEXT_STYLE_PARSER);
				print (string) TEXT_STYLE_PARSER_PREFIX;
				print "No ", (es) self, " algo que puedas manipular de ese modo.";
				print (string) TEXT_STYLE_PARSER_SUFIX;
				Utils.set_text_style(previous_style);
				new_line;
				return true;
		],
		cant_go [;
			switch (Utils.get_grammatical_inflection()) {
				FIRST_PERSON_PRESENT:
					if (IsPluralNoun(player)) print "No vemos";
					else print "No veo";
					print " ninguna salida en esa dirección.";
				SECOND_PERSON_PRESENT:
					if (IsPluralNoun(player)) print "No veis";
					else print "No ves";
					print " ninguna salida en esa dirección.";
				THIRD_PERSON_PRESENT:
					if (IsPluralNoun(player)) print "No ven";
					else print "No ve";
					print " ninguna salida en esa dirección.";
				FIRST_PERSON_PAST:
					if (IsPluralNoun(player)) print "No veíamos";
					else print "No veía";
					print " ninguna salida en aquella dirección.";
				SECOND_PERSON_PAST:
					if (IsPluralNoun(player)) print "No veíais";
					else print "No veías";
					print " ninguna salida en aquella dirección.";
				THIRD_PERSON_PAST:
					if (IsPluralNoun(player)) print "No veían";
					else print "No veía";
					print " ninguna salida en aquella dirección.";
				FIRST_PERSON_FUTURE:
					if (IsPluralNoun(player)) print "No veremos";
					else print "No veré";
					print " ninguna salida en esa dirección.";
				SECOND_PERSON_FUTURE:
					if (IsPluralNoun(player)) print "No veréis";
					else print "No verás";
					print " ninguna salida en esa dirección.";
				THIRD_PERSON_FUTURE:
					if (IsPluralNoun(player)) print "No verán";
					else print "No verá";
					print " ninguna salida en esa dirección.";
			}
			if (self.exits ~= 0) {
				print " ";
				return PrintOrRun(self, exits);
			}
			new_line;
			return true;
		],
		description [;
			if (action == ##Look || self hasnt visited) {
				self.description_verbose();
			} else {
				self.description_brief();
			}
			new_line;
			return true;
		],
		description_verbose 0,
		!! Por defecto la descripción breve es igual a la descripción larga:
		description_brief [;
			return self.description_verbose();
		],
		!! Permite listar las salidas visibles:
		exits 0,
;

!!------------------------------------------------------------------------------
!! Thing:Atrezzo:Room:Indoors
!!------------------------------------------------------------------------------
!!	@version 2019/07/15
!!------------------------------------------------------------------------------
Class	Indoors
 class	Room
;

!!------------------------------------------------------------------------------
!! Thing:Atrezzo:Room:Outdoors
!!------------------------------------------------------------------------------
!!	@version 2019/07/15
!!------------------------------------------------------------------------------
Class	Outdoors
 class	Room
;

!!------------------------------------------------------------------------------
!! Thing:Character
!!------------------------------------------------------------------------------
!! Representa un personaje.
!!
!!	@dependency arrays.h
!!	@dependency textStyles.h
!!	@version 2019/07/15
!!------------------------------------------------------------------------------
Class	Character
 class	Thing,
 has	animate,
 with	before [
			previous_style;
			DefaultAction:
				if (self == player) {
					<<Examine self>>;
				}
				if (self has described) {
					previous_style = Utils.set_text_style(TEXT_STYLE_PARSER);
					print (string) TEXT_STYLE_PARSER_PREFIX;
					print "habla con ";
					PrintToBuffer(utility_array_a, INPUT_BUFFER_LEN, self);
					PrintCharacterArray(utility_array_a);
					print (string) TEXT_STYLE_PARSER_SUFIX;
					Utils.set_text_style(previous_style);
					new_line;
					<<TalkTo self>>;
				}
		],
;

!!------------------------------------------------------------------------------
!! Thing:Item
!!------------------------------------------------------------------------------
!! Representa un objeto simple dentro del modelo de mundo sobre el que
!! inicialmente no se aplican restricciones de ningún tipo.
!!
!!	@version 2019/07/15
!!------------------------------------------------------------------------------
Class	Item
 class	Thing
;

!!------------------------------------------------------------------------------
!! Thing:Item:Clothes
!!------------------------------------------------------------------------------
!! Objetos vestibles. Implementa un mecanismo de capas de modo que no es
!! posible vestir ni desvestir cualquier prenda de una capa mientras el PC
!! lleve puestas prendas de una capa superior.
!!
!!	@dependency SpanishLM.h
!!	@version 2019/09/16
!!------------------------------------------------------------------------------
Class	Clothes
 class	Item
 has	clothing,
 with	before [
			obj i temp layer_a layer_b;
			Disrobe,
			Wear:
				!! Calcula la capa de referencia del objeto:
				for (i = 0 : i < (self.#layer)/WORDSIZE : i++) {
					temp = self.&layer-->i;
					if (temp > layer_a) layer_a = temp;
				}
				!! Comprueba las capas del resto de elementos vestidos por PJ:
				objectloop(obj in player && obj ofclass Clothes
					&& obj has worn && obj ~= self) {
					for (i = 0 : i < (obj.#layer)/WORDSIZE : i++) {
						temp = obj.&layer-->i;
						if (i == 0) layer_b = temp;
						else if (temp < layer_b) layer_b = temp;
					}
					if (layer_a < layer_b) {
						switch (Utils.get_grammatical_inflection()) {
							FIRST_PERSON_PAST:
								if (IsPluralNoun(player))
									print "Teníamos que quitarnos";
								else print "Tenías que quitarme";
							SECOND_PERSON_PAST:
								if (IsPluralNoun(player))
									print "Teníais que quitaros";
								else print "Tenías que quitarte";
							THIRD_PERSON_PAST:
								if (IsPluralNoun(player))
									print "Tenían que quitarse";
								else print "Tenía que quitarse";
							FIRST_PERSON_PRESENT:
								if (IsPluralNoun(player))
									print "Tenemos que quitarnos";
								else print "Tengo que quitarme";
							SECOND_PERSON_PRESENT:
								if (IsPluralNoun(player))
									print "Tenéis que quitaros";
								else print "Tienes que quitarte";
							THIRD_PERSON_PRESENT:
								if (IsPluralNoun(player))
									print "Tienen que quitarse";
								else print "Tiene que quitarse";
							FIRST_PERSON_FUTURE:
								if (IsPluralNoun(player))
									print "Tendremos que quitarnos";
								else print "Tendré que quitarme";
							SECOND_PERSON_FUTURE:
								if (IsPluralNoun(player))
									print "Tendréis que quitaros";
								else print "Tendrás que quitarte";
							THIRD_PERSON_FUTURE:
								if (IsPluralNoun(player))
									print "Tendrán que quitarse";
								else print "Tendrá que quitarse";
						}
						" ", (the) obj, " primero.";
					}
				}
		],
		layer 0,
;

!!------------------------------------------------------------------------------
!! Thing:Item:HeavyItem
!!------------------------------------------------------------------------------
!! Representa un objeto pesado dentro del modelo de mundo. Se le aplica la
!! propiedad 'static' definida por la librería Inform.
!!
!!	@dependency SpanishLM.h
!!	@version 2019/07/15
!!------------------------------------------------------------------------------
Class	HeavyItem
 class	Item
 has	static,
 with	before [;
			Pull,
			Push,
			PushDir,
			Take,
			Turn:
				switch (Utils.get_grammatical_inflection()) {
					FIRST_PERSON_PRESENT,
					SECOND_PERSON_PRESENT,
					THIRD_PERSON_PRESENT:
						print (The) self, " ", (es) self;
					FIRST_PERSON_PAST,
					SECOND_PERSON_PAST,
					THIRD_PERSON_PAST:
						print (The) self, " era", (n) self;
					FIRST_PERSON_FUTURE,
					SECOND_PERSON_FUTURE,
					THIRD_PERSON_FUTURE:
						print (The) self, " será", (n) self;
				} " demasiado pesad", (o) self, " para andar moviéndol",
				(o) self, ".";
		],
;
