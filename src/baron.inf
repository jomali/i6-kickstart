!% -Cu
!% -D
!% -S
!% -s
!% +language_name=Spanish
!% $MAX_PROP_TABLE_SIZE=100000
!% $MAX_STATIC_DATA=25000
!% $MAX_VERBSPACE=4800

!!==============================================================================
!!
!!	EL BARÓN
!!
!!==============================================================================
!!
!!	Archivo:		baron.inf
!!	Autor(es):		Victor Gijsbers
!!					J. Francisco Martín <jfm.lisaso@gmail.com>
!!	Idioma:			ES (Español)
!!	Sistema:		Inform-INFSP 6
!!	Plataforma:		Máquina-Z/Glulx
!!	Versión:		0.0
!!	Fecha:			2019/02/XX
!!
!!------------------------------------------------------------------------------
!!
!!	Este archivo forma parte de la ficción interactiva EL BARÓN.
!!
!!	EL BARÓN es software libre: usted puede redistribuirlo y/o
!!	modificarlo bajo los términos de la Licencia Pública General
!!	GNU publicada por la Fundación para el Software Libre, ya
!!	sea la versión 3 de la Licencia, o (a su elección) cualquier
!!	versión posterior.
!!
!!	EL BARÓN se distribuye con la esperanza de que sea útil,
!!	pero SIN GARANTÍA ALGUNA; ni siquiera la garantía implícita
!!	MERCANTIL o de APTITUD PARA UN PROPÓSITO DETERMINADO.
!!	Consulte los detalles de la Licencia Pública General GNU
!!	para más información.
!!
!!	Debería haber recibido una copia de la Licencia Pública
!!	General GNU junto a EL BARÓN. En caso contrario, consulte
!!	<http://www.gnu.org/licenses/>.
!!
!!	Copyright (c) 2004, Victor Gijsbers
!!	Copyright (c) 2019, J. Francisco Martín
!!
!!------------------------------------------------------------------------------
!!
!!	HISTORIAL DE VERSIONES
!!
!!	0.0: 2019/02/04	Inicio del desarrollo.
!!
!!------------------------------------------------------------------------------
!!
!!	TABLA DE CONTENIDOS
!!
!!	1)	Constantes y variables globales de la obra
!!	2)	Reemplazos de rutinas por defecto
!!	3)	Librerías y extensiones (parte 1 de 2)
!!	4)	Puntos de entrada Glk
!!	5)	Librerías y extensiones (parte 2 de 2)
!!	6)	Puntos de entrada de la librería Inform y del resto de extensiones
!!	7)	Gramática estándar y extendida
!!	8)	Definición de atributos, clases y objetos
!!
!!------------------------------------------------------------------------------


!!==============================================================================
!!
!!	1)	Constantes y variables globales de la obra
!!
!!------------------------------------------------------------------------------
!!	<>	Información bibliográfica
!!	<>	Control de las extensiones utilizadas por la obra
!!	<>	Definiciones generales
!!	<>	Definiciones de la librería Inform
!!	<>	Configuración de la extensión 'choiceSets'
!!	<>	Configuración de la interfaz gráfica con 'GWindows'
!!	<>	Configuración de la extensión 'hyperlinks'
!!	<>	Configuración de la librería de mensajes 'SpanishLM'
!!	<>	Configuración de la extensión 'textStyles'
!!------------------------------------------------------------------------------

!!------------------------------------------------------------------------------
!!	Información bibliográfica
!!------------------------------------------------------------------------------

Constant Story
"EL BARÓN";

Constant Headline
"Una historia interactiva. Escrita por Victor Gijsbers y publicada bajo la Licencia Pública General de GNU en su versión 3 (o cualquier versión posterior). La presente edición ha sido desarrollada por J. Francisco Martín.";

Constant Checking 1;
Release 0;

!! Descomentar para compilar la versión Web/Móvil:
Constant VERSION_WEB_MOBILE;

!!------------------------------------------------------------------------------
!!	Control de las extensiones utilizadas por la obra
!!------------------------------------------------------------------------------

#Ifndef VERSION_WEB_MOBILE;
!! Si no se está compilando para Web/Móvil, es que se compila para escritorio:
Constant VERSION_DESKTOP;
#Endif; ! VERSION_WEB_MOBILE;

#Ifdef VERSION_WEB_MOBILE;
!! Utilización de la interfaz Vorple:
Constant USE_VORPLE;
!! Se evita que Vorple reescriba las rutinas de Inform:
Constant VORPLE_NO_REPLACES;
#Ifnot; ! VERSION_DESKTOP;
!! Utilización del gestor de audio:
Constant USE_DAMUSIX;
!! Utilización de la librería GWindows:
Constant USE_GWINDOWS;
!! Utilización de hipervínculos Glk:
Constant USE_HYPERLINKS;
#Endif; ! VERSION_

!! Utilización de reemplazos de rutinas por defecto de la librería:
Constant USE_EXTENDED_LIBRARY;
!! Utilización de mensajes personalizados de la librería:
Constant USE_SPANISH_LM;

!!------------------------------------------------------------------------------
!!	Definiciones generales
!!------------------------------------------------------------------------------

!! Clases de objetos interactivos:
Constant REMARKABLE_OBJECT 2;
Constant DIRECTION_OBJECT 3;
Constant CHOICE_OBJECT 4;
Constant OTHER_OBJECT 1;

!! Tamaños relativos de los objetos:
Constant SIZE_S 0;
Constant SIZE_M 1;
Constant SIZE_L 2;

!! Nombre del fichero de configuración:
Constant CONFIG_FILE_NAME "baron.params";

!! Referencias a los recursos multimedia en Máquina-Z:
#Ifdef TARGET_ZCODE;
!! TODO
#Endif; ! TARGET_ZCODE;

#Ifndef USE_EXTENDED_LIBRARY;
Attribute described;
#Endif; ! USE_EXTENDED_LIBRARY;

!!------------------------------------------------------------------------------
!!	Definiciones de la librería Inform
!!------------------------------------------------------------------------------

Constant MANUAL_PRONOUNS;		! Los prons. refieren a objetos ya mencionados
Constant NO_PLACES;				! Acciones LUGARES y OBJETOS desactivadas
Constant NO_SCORE;				! No se lleva conteo de puntuación

#Ifdef USE_SPANISH_LM;
Constant SIN_MENSAJES;			! Se omiten los mensajes por defecto de la lib.
#Endif; ! USE_SPANISH_LM;

#Ifdef USE_EXTENDED_LIBRARY;
Constant WITHOUT_DIRECTIONS;	! Se omiten las dir. por defecto de la lib.
#Endif; ! USE_EXTENDED_LIBRARY;

!!------------------------------------------------------------------------------
!!	Configuración de la extensión 'choiceSets'
!!------------------------------------------------------------------------------

Constant CSET_STYLE 1;
Constant CSET_PREFIX "(";
Constant CSET_SUFIX ").";
Constant CSET_MSG1 "";
Constant CSET_MSG2 "";
Constant CSET_COMMA " / ";
Constant CSET_OR " / ";
Constant CSET_NO_MSG "Listado de opciones vacío";

!!------------------------------------------------------------------------------
!!	Configuración de la interfaz gráfica con 'GWindows'
!!------------------------------------------------------------------------------

#Ifdef TARGET_GLULX;
#Ifdef USE_GWINDOWS;
Constant GUICONFIG_MARGIN_COLOR $202020; ! #202020
Object	GUIConfig "(GUI Configuration)"
 with	!!----------------------------------------------------------------------
		graphic_window_flag true,	! estado de las ventanas gráficas
		status_bar_height 1,		! altura de la barra de estado (en filas)
		!!----------------------------------------------------------------------
		!! Configuración por defecto A. Ancho de ventana >= threshold_A
		graphic_width_A 0 0,	! (px)
		margin_A 0 0,			! (%)
		padding_A 0 0 8 0,		! (px)
		threshold_A 0,			! (px)
		!! Configuración por defecto B. Ancho de ventana >= threshold_B
		graphic_width_B 0 0,	! (px)
		margin_B 0 6,			! (%)
		padding_B 0 0 8 0,		! (px)
		threshold_B 460,		! (px)
		!! Configuración por defecto C. Ancho de ventana >= threshold_C
		graphic_width_C 0 0,	! (px)
		margin_C 0 12,			! (%)
		padding_C 0 0 8 0,		! (px)
		threshold_C 660,		! (px)
		!! Configuración por defecto D. Ancho de ventana >= threshold_D
		graphic_width_D 80 80,	! (px)
		margin_D 10 10,			! (%)
		padding_D 40 40 40 40,		! (px)
		threshold_D 900,		! (px)
		!! Configuración por defecto E. Ancho de ventana >= threshold_E
		graphic_width_E 0 0,	! (px)
		margin_E 0 22,			! (%)
		padding_E 0 0 8 0,		! (px)
		threshold_E 1050,		! (px)
		!! Configuración por defecto F. Ancho de ventana >= threshold_F
		graphic_width_F 0 0,	! (px)
		margin_F 0 25,			! (%)
		padding_F 0 0 8 0,		! (px)
		threshold_F 1224,		! (px)
		!! Configuración por defecto G. Ancho de ventana >= threshold_G
		graphic_width_G 0 0,	! (px)
		margin_G 0 30,			! (%)
		padding_G 0 0 8 0,		! (px)
		threshold_G 1400,		! (px)
;
#Ifnot;
#Endif; ! USE_GWINDOWS;
#Endif; ! TARGET_GLULX;

!!------------------------------------------------------------------------------
!!	Configuración de la extensión 'hyperlinks'
!!------------------------------------------------------------------------------

#Ifdef USE_HYPERLINKS;
!! Acción por defecto utilizada al seleccionar un hipervínculo:
Global _hyperlinks_command = "";
#Endif; ! USE_HYPERLINKS;

!!------------------------------------------------------------------------------
!!	Configuración de la librería de mensajes 'SpanishLM'
!!------------------------------------------------------------------------------

#Ifdef USE_SPANISH_LM;
Constant PS1 ">";				! Inductor

Global FORMER__TX	= "tu antiguo ~yo~";
Global YOURSELF__TX	= "ti mismo";
Global CANTGO__TX	= "No puedes ir por ahí.";
Global IS__TX		= " ves";
Global ARE__TX		= " ves";
Global IS2__TX		= "ves ";
Global ARE2__TX		= "ves ";
Global YOU__TX		= "Tú";
Global PARTICULA_TE	= "te";
#Ifnot;
Default FIRST_PERSON_PRESENT	= 1;
Default SECOND_PERSON_PRESENT	= 2;
Default THIRD_PERSON_PRESENT	= 3;
Default FIRST_PERSON_PAST		= 4;
Default SECOND_PERSON_PAST		= 5;
Default THIRD_PERSON_PAST		= 6;
Default FIRST_PERSON_FUTURE		= 7;
Default SECOND_PERSON_FUTURE	= 8;
Default THIRD_PERSON_FUTURE		= 9;
[ contigo; print "contigo"; ];
[ IsPluralNoun; return false; ];
#Endif; ! USE_SPANISH_LM;

!!------------------------------------------------------------------------------
!!	Configuración de la extensión 'textStyles'
!!------------------------------------------------------------------------------

!! Configuración de aspecto para el estilo de texto HEADER:
Constant HEADER_STYLE_BOLD 1;
Constant HEADER_STYLE_ITALIC 0;

!! Configuración de aspecto para el estilo de texto INPUT:
Constant INPUT_STYLE_BOLD 0;
Constant INPUT_STYLE_ITALIC 1;

!! Configuración de aspecto para el estilo de texto NOTE:
Constant NOTE_STYLE_FGC $E06666; ! #E06666
Constant NOTE_STYLE_BOLD 1;
Constant NOTE_STYLE_ITALIC 0;

!! Configuración de aspecto para el estilo de texto QUOTE:
Constant QUOTE_STYLE_FGC $6D9EEB; ! #6D9EEB
Constant QUOTE_STYLE_BOLD 1;
Constant QUOTE_STYLE_ITALIC 1;

!! Configuración de aspecto para el estilo de texto REVERSED:
Constant REVERSED_STYLE_BOLD 0;
Constant REVERSED_STYLE_ITALIC 0;

!! Configuración de aspecto para el estilo de texto USER1:
Constant USR1_STYLE_BGC	$303030; ! #303030
Constant USR1_STYLE_BOLD 0;
Constant USR1_STYLE_ITALIC 0;

!! Configuración de aspecto para el estilo de texto USER2:
Constant USR2_STYLE_FGC	$606060; ! #606060
Constant USR2_STYLE_BOLD 0;
Constant USR2_STYLE_ITALIC 1;

!! Configuración del estilo de texto de mensajes extradiegéticos:
Constant TEXT_STYLE_PARSER TEXT_STYLE_USER2;
Constant TEXT_STYLE_PARSER_PREFIX "[";
Constant TEXT_STYLE_PARSER_SUFIX "]";


!!==============================================================================
!!
!!	2)	Reemplazos de rutinas por defecto
!!
!!------------------------------------------------------------------------------

Replace BeforeSettingTextStyle;	! Lógica previa al cambiar de estilo de texto

#Ifdef USE_SPANISH_LM;
Replace ChangePlayer;			! Rutina para cambiar el objeto PC
#Endif; ! USE_SPANISH_LM;

#Ifdef USE_EXTENDED_LIBRARY;
Replace Banner;					! Créditos generales de la aplicación
Replace DrawStatusLine;			! Dibuja la barra de estado
Replace ExamineSub;				! Rutina para la acción ##Examine
Replace GetGNAOfObject;			! Rutina para obtener el GNA de un objeto
Replace LanguageDirection;		! Imprime el nombre de las direcciones
Replace LMode1Sub;				! Lookmode 1: Breve
Replace LMode2Sub;				! Lookmode 2: Largo (establecido por defecto)
Replace LMode3Sub;				! Lookmode 3: Superbreve
Replace LookSub;				! Rutina para la acción ##Look
Replace PSN__;					! Rutina para imprimir nombre corto de un obj.
Replace VersionSub;				! Créditos detallados de la aplicación
#Endif; ! USE_EXTENDED_LIBRARY;

#Ifdef USE_VORPLE;
Replace MyVorplePrompt;			! Rutina que imprime el inductor en Vorple
#Endif; ! USE_VORPLE;


!!==============================================================================
!!
!!	3)	Librerías y extensiones (parte 1 de 2)
!!
!!------------------------------------------------------------------------------

#Ifdef TARGET_GLULX;
#Ifdef USE_GWINDOWS;
Include "gwindefs.h";			! GWindows: Definiciones
#Endif; ! USE_GWINDOWS;
#Endif; ! TARGET_GLULX;

#Ifdef TARGET_GLULX;
#Ifdef USE_VORPLE;
Include "vorple.h";				! Funcionalidades básicas de Vorple UI
#Endif; ! USE_VORPLE;
#Endif; ! TARGET_GLULX;

Include "Parser.h";				! Decodifica la entrada del teclado
Include "textStyles.h";			! Selección de estilo de los textos

#Ifdef USE_SPANISH_LM;
Include "SpanishLM.h";			! Mensajes de la librería
#Endif; ! USE_SPANISH_LM;

#Ifdef USE_EXTENDED_LIBRARY;
Include ">baron_lib.inf";		! Personalizaciones de la librería
#Endif; ! USE_EXTENDED_LIBRARY;

Include ">baron_langLM.inf";	! Mensajes personalizados de la librería

#Ifdef USE_GWINDOWS;
Include "gwincls.h";			! GWindows: Window Class Framework
#Endif; ! USE_GWINDOWS;


!!==============================================================================
!!
!!	4)	Puntos de entrada Glk
!!
!!------------------------------------------------------------------------------
!!	<>	HandleGlkEventExe() / HandleGlkEvent() / GWindowsGlkEvent()
!!	<>	IdentifyGlkObjectExe() / IdentifyGlkObject() / GWindowsGlkIdentify()
!!	<>	InitGlkWindowExe() / InitGlkWindow() / InitGWindows()
!!
!! NOTA: GWindows hace uso de los puntos de entrada Glk por defecto, por lo
!! cuál define los suyos propios para reemplazar aquellos de la librería.
!!------------------------------------------------------------------------------

!!------------------------------------------------------------------------------
!! Punto de entrada para manejar eventos Glk.
!!
!!	@param {array} ev - Array de 4 palabras que describe el evento. ev-->0
!!		registra un código numérico con que se determina el tipo de evento. La
!!		rutina sólo actúa si se trata de un evento de tipo hipervínculo
!!		(ev-->0 == 8); ev-->1 indica la ventana sobre la que se ha producido el
!!		evento; ev-->2 el objeto o cadena de caracteres sobre el que se ha
!!		creado el hipervínculo; ev-->3, reservado para información adicional,
!!		no se utiliza
!!	@param {integer} context - 0 si el evento se ha producido durante una
!!		entrada de línea (comandos normales u otros usos de la función de la
!!		librería 'KeyboardPrimitive()'); la aplicación debe esperar a que el
!!		usuario pulse INTRO antes de dar respuesta para la entrada. 1 si el
!!		evento se ha producido durante una entrada de caracter (función de la
!!		librería 'KeyCharPrimitive()'); la aplicación responde ante cada
!!		pulsación de tecla, como en los menús, por ejemplo
!!	@param {array} abortres - Utilizado para cancelar la entrada de texto y
!!		forzar una entrada particular. La longitud de la nueva entrada se
!!		registra en 'abortres-->0'. Si es diferente de 0, los caracteres del
!!		comando deben escribirse en el array secuencialmente desde la posición
!!		'abortres->WORDSIZE' hasta 'abortres->(WORDSIZE+length)' (no
!!		inclusive). No pueden superarse los 256 caracteres
!!	@returns {integer|boolean} 2 para que la entrada de usuario sea abortada.
!!		-1 para que la entrada de usuario continúe incluso después de una
!!		pulsación de INTRO (para las entradas de línea) o de tecla (para las
!!		entradas de caracter). Cualquier otro valor de retorno continuará con
!!		la ejecución normal de la librería
!!------------------------------------------------------------------------------
#Ifdef TARGET_GLULX;
#Ifdef USE_GWINDOWS;
[ GWindowsGlkEvent ev context abortres;
 	return HandleGlkEventExe(ev, context, abortres);
];
#Ifnot;
[ HandleGlkEvent ev context abortres;
 	return HandleGlkEventExe(ev, context, abortres);
];
#Endif; ! USE_GWINDOWS;
[ HandleGlkEventExe ev context abortres;
	!! Gestión de efecto de 'fade' en Damusix en tiempo real:
	#Ifdef USE_DAMUSIX;
	Damusix.NotificarFade(ev);
	#Endif; ! USE_DAMUSIX;

	!! Gestión de los eventos de selección de hipervínculo:
	#Ifdef USE_HYPERLINKS;
	if (HandleHyperlinkEvent(ev, context, abortres)) {
		return 2; ! finaliza el turno
	}
	#Endif; ! USE_HYPERLINKS

	ev = context + abortres; ! (por evitar alertas del compilador)
];
#Endif; ! TARGET_GLULX;

!!------------------------------------------------------------------------------
!! 'IdentifyGlkObject()' permite conocer qué objetos Glk existen; útil para
!! gestionar las directivas RESTORE, RESTART y UNDO puesto que, tras utilizar
!! estas entradas, las variables globales con objetos Glk pueden contener
!! valores desfasados y erróneos.
!!
!!	@param {integer} phase - Código numérico indicando la fase en la que se
!!		invoca a la rutina. Toma los valores: 0, 1 o 2
!!	@param {integer} type - 0, 1 o 2 para ventanas, 'streams' y 'filerefs',
!!		respectivamente
!!	@param {Object} ref
!!	@param {integer} rock
!!------------------------------------------------------------------------------
#Ifdef TARGET_GLULX;
#Ifdef USE_GWINDOWS;
[ GWindowsGlkIdentify phase type ref rock;
	return IdentifyGlkObjectExe(phase, type, ref, rock);
];
#Ifnot;
[ IdentifyGlkObject phase type ref rock;
	return IdentifyGlkObjectExe(phase, type, ref, rock);
];
#Endif; ! USE_GWINDOWS;
[ IdentifyGlkObjectExe phase type ref rock;
	!! Se identifican todos los objetos de sonido gestionados por Damusix:
	#Ifdef USE_DAMUSIX;
	Damusix.IdentificarSonidos(phase);
	#Endif; ! USE_DAMUSIX;

	phase = type + ref + rock; ! (por evitar alertas del compilador)
];
#Endif; ! TARGET_GLULX;

!!------------------------------------------------------------------------------
!! 'InitGlkWindow()' es un punto de entrada es invocado por la librería cuando
!! establece las ventanas por defecto: la ventana de texto principal, la
!! ventana de estado y la ventana para caja de citas (en caso de utilizarlas).
!! La ventana de texto principal y la ventana de estado son creadas al iniciar
!! la aplicación (antes de 'Initialise()'). La ventana de citas es creada y
!! destruida según se necesite. Este punto de entrada es invocado en 5 fases:
!!
!!	1)	Al inicio de la ejecución (antes incluso del punto de entrada
!!		'Initialise()') se hace la invocación 'InitGlkWindow(0)'. Aquí se
!!		pueden efectuar cualesquiera inicializaciones de ventanas Glk (se debe
!!		tener en cuenta, no obstante, que las ventanas de texto principal y de
!!		estado pueden estar ya inicializadas —por ejemplo si el usuario acaba
!!		de utilizar la instrucción RESTART—). Este es un buen momento para
!!		establecer 'gg_statuswin_size' a un valor distinto de 1. Retornar 0
!!		para proceder con el resto de inicializaciones de ventanas por defecto
!!		de la librería, o 1 si ya se han inicializado todas las ventanas
!!		manualmente.
!!	2)	La librería invoca a 'InitGlkWindow(GG_MAINWIN_ROCK)' antes de crear la
!!		ventana de texto principal. Este es un buen momento para inicializar
!!		las recomendaciones de aspecto de la ventana de texto. Retornar 0 para
!!		permitir que la librería continúe normalmente con la creación de la
!!		ventana, o 1 si la ventana ya se ha creado y registrado en la variable
!!		'gg_mainwin' manualmente.
!!	3)	La librería invoca a 'InitGlkWindow(GG_STATUSWIN_ROCK)' antes de crear
!!		la ventana de estado. De nuevo, se puede retornar 0 para permitir que
!!		la librería cree la ventana normalmente, o 1 si la ventana ya se ha
!!		creado y registrado en la variable 'gg_statuswin' manualmente.
!!	4)	Al final de la inicialización de las ventanas Glk se invoca
!!		'InitGlkWindow(1)'. En este momento se pueden abrir otras ventanas Glk
!!		(o pueden abrirse igualmente en la rutina 'Initialise()').
!!	5)	La librería invoca 'InitGlkWindow(GG_QUOTEWIN_ROCK)' antes de crear la
!!		ventana de caja de citas. Esto no ocurre durante la inicialización de
!!		la aplicación sino durante la ejecución, siempre que se efectúe una
!!		impresión en la caja de citas, y la ventana es destruída después un
!!		turno más tarde. Como siempre, se puede retornar 1 para indicar que la
!!		ventana ya ha sido creada y registrada en 'gg_quotewin' manualmente.
!!		(El número de líneas deseadas para la ventana puede consultarse en
!!		'gg_arguments-->0').
!!
!! Independientemente de la forma en que se gestione la inicialización de las
!! ventanas, debe tenerse en cuenta que la librería requiere de una ventana
!! principal registrada en 'gg_mainwin'. En caso de no crear una manualmente y
!! no permitir que la librería lo haga de manera automática, la aplicación se
!! cerrará. Las ventanas de estado y de caja de citas, por el contrario, son
!! completamante opcionales; la librería se comportará correctamente sin ellas.
!!
!! La librería GWindows hace uso del punto de entrada 'InitGlkWindow()'. En su
!! lugar, ofrece el punto de entrada 'InitGlkWindow()', sin argumentos, que es
!! equivalente a invocar 'InitGlkWindow(0)'. Debe establecer las variables
!! 'Active_UI', con la raíz del árbol de ventanas; y 'Main_GWindow', con el
!! objeto 'GWindow' que sirve de ventana principal de la aplicación. Se cumple
!! que la variable: 'gg_mainwin == Main_GWindow.winid'.
!!
!!	@param {integer} winrock
!!	@returns {integer}
!!------------------------------------------------------------------------------
#Ifdef TARGET_GLULX;
#Ifdef USE_GWINDOWS;
[ InitGWindows;
	!! Inicializaciones de la interfaz gráfica GWindows:
	Active_UI = rootUI;
	Main_GWindow = textWindow;
	return InitGlkWindowExe(GG_MAINWIN_ROCK);
];
#Ifnot;
[ InitGlkWindow winrock;
	return InitGlkWindowExe(winrock);
];
#Endif; ! USE_GWINDOWS;
[ InitGlkWindowExe winrock
	wintype;
	if (winrock == GG_MAINWIN_ROCK) {
		!! [0:wintype_AllTypes, 1:wintype_Pair, 2:wintype_Blank,
		!! 3:wintype_TextBuffer, 4:wintype_TextGrid, 5:wintype_Graphics]
		wintype = 0;

	    !! Sugerencias de aspecto de 'textStyles':
	    InitialiseStyleHints(winrock, wintype);

		!! Sugerencias de aspecto del estilo HEADER:
		#Ifdef HEADER_STYLE_BOLD;
		glk($00B0, 3, 3, 4, HEADER_STYLE_BOLD);
		#Endif; ! HEADER_STYLE_BOLD
		#Ifdef HEADER_STYLE_ITALIC;
		glk($00B0, 3, 3, 5, HEADER_STYLE_ITALIC);
		#Endif; ! HEADER_STYLE_ITALIC
		#Ifdef HEADER_STYLE_FGC;
		glk($00B0, 3, 3, 7, HEADER_STYLE_FGC);
		#Endif; ! HEADER_STYLE_FGC
		#Ifdef HEADER_STYLE_BGC;
		glk($00B0, 3, 3, 8, HEADER_STYLE_BGC);
		#Endif; ! HEADER_STYLE_BGC

		!! Sugerencias de aspecto del estilo INPUT:
		#Ifdef INPUT_STYLE_BOLD;
		glk($00B0, 3, 8, 4, INPUT_STYLE_BOLD);
		#Endif; ! INPUT_STYLE_BOLD
		#Ifdef INPUT_STYLE_ITALIC;
		glk($00B0, 3, 8, 5, INPUT_STYLE_ITALIC);
		#Endif; ! INPUT_STYLE_ITALIC
		#Ifdef INPUT_STYLE_FGC;
		glk($00B0, 3, 8, 7, INPUT_STYLE_FGC);
		#Endif; ! INPUT_STYLE_FGC
		#Ifdef INPUT_STYLE_BGC;
		glk($00B0, 3, 8, 8, INPUT_STYLE_BGC);
		#Endif; ! INPUT_STYLE_BGC

		!! Sugerencias de aspecto del estilo NOTE:
		#Ifdef NOTE_STYLE_BOLD;
		glk($00B0, 3, 6, 4, NOTE_STYLE_BOLD);
		#Endif; ! NOTE_STYLE_BOLD
		#Ifdef NOTE_STYLE_ITALIC;
		glk($00B0, 3, 6, 5, NOTE_STYLE_ITALIC);
		#Endif; ! NOTE_STYLE_ITALIC
		#Ifdef NOTE_STYLE_FGC;
		glk($00B0, 3, 6, 7, NOTE_STYLE_FGC);
		#Endif; ! NOTE_STYLE_FGC
		#Ifdef NOTE_STYLE_BGC;
		glk($00B0, 3, 6, 8, NOTE_STYLE_BGC);
		#Endif; ! NOTE_STYLE_BGC

		!! Sugerencias de aspecto del estilo QUOTE:
		glk($00B0, 3, 7, 6, 1); ! elimina el efecto proporcional
		#Ifdef QUOTE_STYLE_BOLD;
		glk($00B0, 3, 7, 4, QUOTE_STYLE_BOLD);
		#Endif; ! QUOTE_STYLE_BOLD
		#Ifdef QUOTE_STYLE_ITALIC;
		glk($00B0, 3, 7, 5, QUOTE_STYLE_ITALIC);
		#Endif; ! QUOTE_STYLE_ITALIC
		#Ifdef QUOTE_STYLE_FGC;
		glk($00B0, 3, 7, 7, QUOTE_STYLE_FGC);
		#Endif; ! QUOTE_STYLE_FGC
		#Ifdef QUOTE_STYLE_BGC;
		glk($00B0, 3, 7, 8, QUOTE_STYLE_BGC);
		#Endif; ! QUOTE_STYLE_BGC

		!! Sugerencias de aspecto del estilo REVERSED:
		glk($00B0, 3, 5, 9, 0); ! elimina el efecto revertido
		#Ifdef REVERSED_STYLE_BOLD;
		glk($00B0, 3, 5, 4, REVERSED_STYLE_BOLD);
		#Endif; ! REVERSED_STYLE_BOLD
		#Ifdef REVERSED_STYLE_ITALIC;
		glk($00B0, 3, 5, 5, REVERSED_STYLE_ITALIC);
		#Endif; ! REVERSED_STYLE_ITALIC
		#Ifdef REVERSED_STYLE_FGC;
		glk($00B0, 3, 5, 7, REVERSED_STYLE_FGC);
		#Endif; ! REVERSED_STYLE_FGC
		#Ifdef REVERSED_STYLE_BGC;
		glk($00B0, 3, 5, 8, REVERSED_STYLE_BGC);
		#Endif; ! REVERSED_STYLE_BGC

		!! Sugerencias de aspecto del estilo USER1:
		#Ifdef USR1_STYLE_BOLD;
		glk($00B0, 3, 9, 4, USR1_STYLE_BOLD);
		#Endif; ! USR1_STYLE_BOLD
		#Ifdef USR1_STYLE_ITALIC;
		glk($00B0, 3, 9, 5, USR1_STYLE_ITALIC);
		#Endif; ! USR1_STYLE_ITALIC
		#Ifdef USR1_STYLE_FGC;
		glk($00B0, 3, 9, 7, USR1_STYLE_FGC);
		#Endif; ! USR1_STYLE_FGC
		#Ifdef USR1_STYLE_BGC;
		glk($00B0, 3, 9, 8, USR1_STYLE_BGC);
		#Endif; ! USR1_STYLE_BGC

		!! Sugerencias de aspecto del estilo USER2:
		#Ifdef USR2_STYLE_BOLD;
		glk($00B0, 3, 10, 4, USR2_STYLE_BOLD);
		#Endif; ! USR2_STYLE_BOLD
		#Ifdef USR2_STYLE_ITALIC;
		glk($00B0, 3, 10, 5, USR2_STYLE_ITALIC);
		#Endif; ! USR2_STYLE_ITALIC
		#Ifdef USR2_STYLE_FGC;
		glk($00B0, 3, 10, 7, USR2_STYLE_FGC);
		#Endif; ! USR2_STYLE_FGC
		#Ifdef USR2_STYLE_BGC;
		glk($00B0, 3, 10, 8, USR2_STYLE_BGC);
		#Endif; ! USR2_STYLE_BGC
	}
    !! Se continúa con el proceso normal de la librería:
    return false;
];
#Endif; ! TARGET_GLULX;


!!==============================================================================
!!
!!	5)	Librerías y extensiones (parte 2 de 2)
!!
!!------------------------------------------------------------------------------

#Ifdef USE_DAMUSIX;
Include "damusix.h";			! Administrador unificado de sonido en GLULX
#Endif; ! USE_DAMUSIX;

#Ifdef USE_GWINDOWS;
Include "gwindows.h";			! GWindows: Reemplazos de la librería
Include "gWindowsGUI.h";		! Interfaz gráfica adaptativa con GWindows
#Endif; ! USE_GWINDOWS;

#Ifdef TARGET_GLULX;
Include ">baron.bli";			! Recursos multimedia de la aplicación
#Endif; ! TARGET_GLULX;

Include "arrays.h";				! Operaciones con arrays
Include "capacities.h";			! Extensión a las reglas de capacidad
Include "choiceSets.h";			! Sistema de selección de acciones sobre lista
Include "pPreprocessor.h";		! Preprocesador del parser
Include "shuffle.h";			! Barajeado de números aleatorios

#Ifdef USE_HYPERLINKS;
Include	"hyperlinks.h";			! Rutinas de apoyo para el uso de hipervínculos
#Endif; ! USE_HYPERLINKS;

Include "VerbLib.h";			! Define cómo trabajan las acciones

#Ifdef USE_VORPLE;
Include "vorple-command-prompt-control.h";
Include "vorple-hyperlinks.h";
Include "vorple-multimedia.h";
Include "vorple-screen-effects.h";
#Endif; ! USE_VORPLE;


!!==============================================================================
!!
!!	6)	Puntos de entrada de la librería Inform y del resto de extensiones
!!
!!------------------------------------------------------------------------------
!!	<>	AfterPrompt()
!!	<>	BeforeParsing()
!!	<>	BeforeSettingTextStyle()
!!	<>	GamePostRoutine()
!!	<>	Initialise()
!!	<>	InScope()
!!	<>	MyVorplePrompt()
!!	<>	PrintVerb()
!!	<>	UnknownVerb()
!!------------------------------------------------------------------------------

!!------------------------------------------------------------------------------
!! Punto de entrada invocado justo tras la impresión del inductor (prompt); es
!! decir, después de que todas las impresiones en pantalla derivadas del turno
!! actual hayan finalizado.
!!
!!	@returns Nada
!!	@version 2019/06/24
!!------------------------------------------------------------------------------
[ AfterPrompt;
	#Ifdef USE_VORPLE;
	!! Simula el evento de haber dejado de pulsar una de las teclas para
	!! resaltar palabras clave, de modo que tras cada acción ejecutada, las
  	!! palabras clave vuelven a dejar de estar resaltadas:
	VorpleExecuteJavaScriptCommand(BuildCommand("
		ifjs.keyUp({ keyCode: ifjs.config.highlightKeyCodes[0] });
	"));
	#Endif; ! USE_VORPLE;
];

!!------------------------------------------------------------------------------
!! Permite manipular la entrada de usuario antes de que sea analizada por la
!! librería. Es invocada después de que el sistema haya leído la entrada de
!! texto y haya definido ya las tablas 'buffer' y 'parser', pero aún no ha
!! hecho nada más salvo establecer el contador de palabras 'wn' a 1. La rutina
!! puede manipular estas tablas libremente mientras permanezcan consistentes la
!! una con la otra, y puede dejar el contador de palabras en cualquier punto.
!!
!!	@returns Nada
!!	@version 2019/07/15
!!------------------------------------------------------------------------------
[ BeforeParsing;
	#Ifdef CHOICE_SETS;
	ChoiceSetManager.run();
	#Endif; ! CHOICE_SETS;
	#Ifdef PARSING_PREPROCESSOR;
	ParsingPreprocessor.run();
	#Endif; ! PARSING_PREPROCESSOR;
];

!!------------------------------------------------------------------------------
!! Permite añadir lógica antes de establecer un nuevo estilo de texto a través
!! de la extensión 'textStyles'. Se encarga de seleccionar los estilos de texto
!! en Vorple.
!!
!!	@param {integer} previous_style - Código del estilo de texto actual
!!	@param {integer} next_style - Código del nuevo estilo de texto
!!	@returns {boolean} Verdadero para interrumpir la ejecución normal de la
!!		rutina de selección de estilo de texto. Falso para continuar
!!		normalmente
!!	@version 2019/06/18
!!------------------------------------------------------------------------------
#Ifdef TEXT_STYLES;
[ BeforeSettingTextStyle previous_style next_style
	applied_styles i;
	#Ifdef USE_VORPLE;
	if (isVorpleSupported()) {
		!! Finaliza los estilos aplicados anteriormente:
		if (previous_style == TEXT_STYLE_REVERSED) {
			applied_styles = 2;
		} else if (previous_style == TEXT_STYLE_STRESSED
			or TEXT_STYLE_IMPORTANT or TEXT_STYLE_MONOSPACED
			or TEXT_STYLE_NOTE or TEXT_STYLE_HEADER
			or TEXT_STYLE_INPUT or TEXT_STYLE_QUOTE
			or TEXT_STYLE_USER1 or TEXT_STYLE_USER2) {
			applied_styles = 1;
		} else { ! (previous_style == TEXT_STYLE_UPRIGHT)
			applied_styles = 0;
		}
		for (i = 0 : i < applied_styles : i++) {
			VorpleEndStyle();
		}
		!! Aplica los nuevos estilos:
		switch (next_style) {
			TEXT_STYLE_UPRIGHT:
				;
			TEXT_STYLE_STRESSED:
				VorpleStyle(STYLE_EMPHASIS);
			TEXT_STYLE_IMPORTANT:
				VorpleStyle(STYLE_STRONG);
			TEXT_STYLE_MONOSPACED:
				VorpleStyle(STYLE_MONOSPACE);
			TEXT_STYLE_REVERSED:
				VorpleStyle(STYLE_DARK_GRAY_LETTERS);
				VorpleStyle(STYLE_LIGHT_GRAY_BACKGROUND);
			TEXT_STYLE_HEADER:
				VorpleStyle(STYLE_LARGE);
			TEXT_STYLE_NOTE:
				VorpleStyle(STYLE_RED_LETTERS);
			TEXT_STYLE_QUOTE:
				VorpleStyle(STYLE_BLUE_LETTERS);
			TEXT_STYLE_INPUT:
				VorpleStyle(STYLE_FANTASY);
			TEXT_STYLE_USER1:
				VorpleStyle(STYLE_YELLOW_BACKGROUND);
			TEXT_STYLE_USER2:
				VorpleStyle(STYLE_LIGHT_GRAY_LETTERS);
		}
	}
	#Endif; ! USE_VORPLE;
	previous_style = next_style + applied_styles + i;
	!! Continúa con la ejecución normal de 'SetTextStyle()':
	return false;
];
#Endif; ! TEXT_STYLES;

!!------------------------------------------------------------------------------
!! Inicializaciones del relato. Esta rutina es obligatoria y, entre otras
!! posibles inicializaciones, DEBE ESTABLECER LA LOCALIDAD INICIAL del usuario
!! (o el objeto accesible —contenedor o soporte— en el que empieza).
!!
!!	@returns {boolean|integer} Verdadero o falso para continuar con la
!!		ejecución normal de la aplicación, o 2 para suprimir la impresión de
!!		los créditos, que de otra manera se imprimirían inmediatamente después
!!		de llamar a la rutina
!!	@version 2019/06/18
!!------------------------------------------------------------------------------
[ Initialise
	previous_style;
	Utils.erase_window();

	!! Inicializaciones para la VM Glulx ---------------------------------------
	Utils.initialise_glulx();

	!! Advertencia de contenidos -----------------------------------------------
	#Ifndef DEBUG;
	new_line;
	print (strong) "ADVERTENCIA", "^";
	new_line;
	print "Los contenidos de esta obra no son apropiados para un público
	infantil. La edad recomendada por el autor a partir de la que experimentar
	la historia son los ", (strong) "quince", " años. Se advierte, además,
	acerca de la naturaleza violenta y moralmente reprobable de ciertos temas y
	situaciones que se abordan en la obra y que pueden herir la sensibilidad de
	algunos usuarios.^";
	new_line;
	new_line;
	print (parser) "Pulsa una tecla.";
	new_line;
	Utils.press_any_key();
	Utils.erase_window();
	#Endif; ! DEBUG;

	!! Comprobación de los ficheros de configuración ---------------------------
	#Ifdef TARGET_GLULX;
	#Ifdef VERSION_DESKTOP;
	!! XXX - Permite inicializar un fichero 'garglk.ini' (descomentar):
	!! if (Utils.write_garglk_configuration_file() == 1) {
	!! 	print "Se acaba de escribir correctamente el fichero de
	!! 	configuración ", (stressed) "~garglk.ini~", " en tu equipo. Es
	!! 	necesario volver a iniciar la aplicación.";
	!! 	new_line;
	!! 	quit;
	!! }
	#Endif; ! VERSION_DESKTOP;
	#Endif; ! TARGET_GLULX;

	!! Configuración de los sistemas de hipervínculos y palabras destacadas ----
	#Ifdef TARGET_GLULX;
	!! Hipervínculos:
	Utils.set_hyperlinks_status(REMARKABLE_OBJECT, true);
	Utils.set_hyperlinks_status(DIRECTION_OBJECT, true);
	Utils.set_hyperlinks_status(CHOICE_OBJECT, true);
	Utils.set_hyperlinks_status(OTHER_OBJECT, true);
	!! Palabras destacadas:
	#Ifdef VERSION_WEB_MOBILE;
	Utils.set_highlight_style(REMARKABLE_OBJECT, TEXT_STYLE_NOTE);
	Utils.set_highlight_style(DIRECTION_OBJECT, TEXT_STYLE_QUOTE);
	Utils.set_highlight_style(CHOICE_OBJECT, TEXT_STYLE_NOTE);
	Utils.set_highlight_style(OTHER_OBJECT, TEXT_STYLE_NOTE);
	#Ifnot; ! VERSION_DESKTOP;
	Utils.set_highlight_style(REMARKABLE_OBJECT, TEXT_STYLE_NOTE);
	Utils.set_highlight_style(DIRECTION_OBJECT, TEXT_STYLE_QUOTE);
	Utils.set_highlight_style(CHOICE_OBJECT, TEXT_STYLE_IMPORTANT);
	Utils.set_highlight_style(OTHER_OBJECT, TEXT_STYLE_UPRIGHT);
	#Ifdef CONFIG_FILE_NAME;
	if (~~Utils.read_configuration_file(CONFIG_FILE_NAME)) {
		print "Es posible experimentar ";
		previous_style = Utils.set_text_style(TEXT_STYLE_HEADER);
		print (string) Story;
		Utils.set_text_style(previous_style);
		print " simplemente haciendo ~clic~ con el ratón sobre las palabras ",
		(note) "destacadas", " que vayas encontrando. ¿Quieres activar esta
		funcionalidad?";
		new_line;
		new_line;
		print (parser) "Teclea: SÍ / NO", " > ";
		if (YesOrNo()) {
			print (parser) "Hipervínculos activados.";
		} else {
			Utils.set_hyperlinks_status(REMARKABLE_OBJECT, false);
			Utils.set_hyperlinks_status(DIRECTION_OBJECT, false);
			Utils.set_hyperlinks_status(CHOICE_OBJECT, false);
			Utils.set_hyperlinks_status(OTHER_OBJECT, false);
			print (parser) "Hipervínculos desactivados.";
		}
		new_line;
		new_line;
		print "Puedes cambiar la configuración anterior en cualquier momento
		tecleando la instrucción ~HIPERVÍNCULOS~.";
		new_line;
		new_line;
		print (parser) "Pulsa una tecla.";
		Utils.press_any_key();
		Utils.erase_window();
	}
	#Endif; ! CONFIG_FILE_NAME;
	#Endif; ! VERSION_
	#Endif; ! TARGET_GLULX;

	!! Inicializaciones de la obra ---------------------------------------------

	!! Contenidos de la barra de estado centrados en pantalla:
	Utils.set_status_bar_alignment(1); ! 0=left; 1=center; 2=right

	!! Narrador en pasado y segunda persona
	Utils.set_grammatical_inflection(SECOND_PERSON_PRESENT);

	!! Establece el estilo del inventario:
	!! inventory_style = ENGLISH_BIT + RECURSE_BIT + FULLINV_BIT;

	!! Establece el PC (player character)
	ChangePlayer(Baron);

	!! Lookmode largo:
	lookmode = 2;

	!! Menú principal:
	location = MainMenu.run(true);

	!! Se evita la impresión inicial del banner
	return 2;
];

!!------------------------------------------------------------------------------
!! Definición del foco del usuario; permite cambiar en el sistema la definición
!! de lo que se encuentra al alcance del PC. Utiliza las rutinas de la librería
!! 'ScopeWithin()' y 'PlaceInScope()' para establecer cuál debería ser el foco.
!!
!!	@returns {boolean} Falso para indicar al sistema que añada todos los
!!		objetos que suelen estar por defecto al alcance, o verdadero para
!!		indicar que no se debe añadir nada más al alcance
!!	@version 2019/06/18
!!------------------------------------------------------------------------------
[ InScope person
	item;
	!! Aseguramos que la localidad actual está siempre en el foco del PJ:
	PlaceInScope(real_location);
	!! En la oscuridad, se mueven al foco todos aquellos objetos que hayan sido
	!! manipulados ya previamente por el PC:
	if ((person == player) && (location == thedark)) {
		objectloop(item in parent(self))
			if (item has moved) PlaceInScope(item);
	}

	return false;
];

!!------------------------------------------------------------------------------
!! Permite imprimir un inductor personalizado en Vorple.
!!
!!	@returns {boolean} Verdadero si se imprime el inductor definido en la
!!		constante PS1 (si es que existe y está bien definido). Falso en caso
!!		contrario
!!	@version 2019/06/18
!!------------------------------------------------------------------------------
#Ifdef TARGET_GLULX;
#Ifdef USE_VORPLE;
[ MyVorplePrompt;
	#Ifdef PS1;
	if (metaclass(PS1) == String) {
		print (string) PS1;
		return true;
	}
	#Endif; ! PS1;
	return false;
];
#Endif; ! USE_VORPLE;
#Endif; ! TARGET_GLULX;

!!------------------------------------------------------------------------------
!! Permite cambiar el verbo que imprime el sistema al hacer al usuario
!! preguntas del tipo: "Intenta de nuevo porque sólo se pudo entender que
!! quieres <lo que sea>.", en caso de que se haya definido alguna acción
!! inusual por medio de la rutina 'UnknownVerb()'.
!!
!!	@param {address} word - Dirección de diccionario del verbo
!!	@returns {boolean} Verdadero para indicar al sistema que se ha imprimido la
!!		forma modificada del verbo, o falso para continuar con la ejecución
!!		normal y que el sistema imprima el verbo de la forma habitual
!!	@version 2019/06/18
!!------------------------------------------------------------------------------
[ PrintVerb word;
	if (word == 'no.verb') {
		print "hacer algo con";
		return true;
	}

	return false;
];

!!------------------------------------------------------------------------------
!! Invocada por el sistema cuando se encuentra con un verbo desconocido, de
!! forma que pueda cambiarse por uno definido en el relato.
!!
!!	@returns {boolean} Falso para permitir que el sistema continúe con la
!!		ejecución normal e imprima un mensaje de error, o un valor de
!!		diccionario del verbo a utilizar en lugar del verbo desconocido
!!	@version 2019/06/18
!!------------------------------------------------------------------------------
[ UnknownVerb
	obj;
	obj = ParsingPreprocessor.get_selected_object();
	if (TestScope(obj, player)) {
		verb_wordnum = 0;
		return 'no.verb';
	}

	return false;
];


!!==============================================================================
!!
!!	7)	Gramática estándar y extendida
!!
!!------------------------------------------------------------------------------

Include "SpanishG.h";			! Gramática española
Include "SpanishEG.h";			! Gramática española extendida

!! Elemento gramático que permite contemplar sólo el primer término de la
!! entrada de usuario:
[ Anything;
	while (NextWordStopped() ~= -1);
	return GPR_PREPOSITION;
];

!!------------------------------------------------------------------------------
!! ##Audio / ##AudioOn / ##AudioOff
!!------------------------------------------------------------------------------

#Ifdef TARGET_GLULX;
#Ifdef USE_DAMUSIX;
Verb meta 'audio' 'music' 'musica' 'sonido' 'sonidos'
	*								-> Audio
	* 'on' / 'si'					-> AudioOn
	* 'encendido' / 'activado'		-> AudioOn
	* 'off' / 'no'					-> AudioOff
	* 'apagado' / 'desactivado'		-> AudioOff
;
VerboIrregular "establecer la reproducción de audio" with imperativo
	'audio' 'music' 'musica' 'sonido' 'sonidos';

[ AudioSub;
	if (Damusix.HayAudio()) <<AudioOff>>;
	else <<AudioOn>>;
];

[ AudioOnSub;
	if (Damusix.HayAudio())
		print_ret (parser) "La reproducción de audio ya estaba activada.";
	Damusix.ActivarAudio();
	print_ret (parser) "Reproducción de audio activada.";
];

[ AudioOffSub;
	if (~~Damusix.HayAudio())
		print_ret (parser) "La reproducción de audio ya estaba desactivada.";
	Damusix.DesactivarAudio();
	print_ret (parser) "Reproducción de audio desactivada.";
];
#Endif; ! USE_DAMUSIX;
#Endif; ! TARGET_GLULX;

!!------------------------------------------------------------------------------
!! ##ConfigureHighlights
!!------------------------------------------------------------------------------

#Ifdef TARGET_GLULX;
#Ifdef VERSION_DESKTOP;
Verb meta 'destacado' 'resaltado'
	*								-> ConfigureHighlights
;

VerboIrregular "establecer configuración de palabras resaltadas"
 with	imperativo 'destacado' 'resaltado',
;

[ ConfigureHighlightsSub
	done highlight_code i number_of_classes previous_style temp txt;
	number_of_classes = 4;
	txt = "INTRO";
	Utils.set_status_bar_contents("Resaltado");
	while (~~done) {
		Utils.erase_window();
		new_line;
		print "Los nombres de los distintos objetos interactivos presentes en
		la obra se pueden imprimir con un estilo de texto resaltado para
		facilitar su identifición. Introduce el número de una clase de objeto
		para rotar entre los distintos estilos de resaltado disponibles y
		seleccionar aquel que mejor se adecue a tus preferencias personales:";
		new_line;
		new_line;
		for (i = 1 : i <= number_of_classes : i++) {
			switch (i) {
				1:	print "1) Objetos importantes: ";
				2:	print "2) Salidas y direcciones: ";
				3:	print "3) Temas de conversación: ";
				4:	print "4) Otros objetos: ";
			}
			highlight_code = Utils.get_highlight_style(i+1);
			if (i == 4) highlight_code = Utils.get_highlight_style(1);
			switch (highlight_code) {
				TEXT_STYLE_HEADER:		temp = "enfatizado (c)";
				TEXT_STYLE_IMPORTANT:	temp = "negrita";
				TEXT_STYLE_MONOSPACED:	temp = "monoespaciado";
				TEXT_STYLE_NOTE:		temp = "enfatizado (a)";
				TEXT_STYLE_QUOTE:		temp = "enfatizado (b)";
				TEXT_STYLE_STRESSED:	temp = "cursiva";
				TEXT_STYLE_UPRIGHT, -1:	temp = "sin estilo";
				TEXT_STYLE_USER1:		temp = "color de fondo";
			}
			previous_style = Utils.set_text_style(highlight_code);
			print (string) temp;
			Utils.set_text_style(previous_style);
			print ".";
			new_line;
		}
		new_line;
		print "NOTA: El repertorio de estilos es más limitado cuando los
		hipervínculos están activados. Puedes igualmente modificar su
		configuración tecleando HIPERVÍNCULOS en la pantalla principal de la
		aplicación.";
		new_line;
		new_line;
		previous_style = Utils.set_text_style(TEXT_STYLE_PARSER);
		print (string) TEXT_STYLE_PARSER_PREFIX;
		print "Pulsa @<<", (string) txt, "@>> para aceptar.";
		print (string) TEXT_STYLE_PARSER_SUFIX;
		Utils.set_text_style(previous_style);
		i = 0;
		switch (Utils.press_any_key()) {
			32, -6: ! INTRO/ESPACIO
				done = true;
			'1':
				i = 2;
			'2':
				i = 3;
			'3':
				i = 4;
			'4':
				i = 1;
		}
		if (i ~= 0) {
			highlight_code = Utils.get_highlight_style(i);
			switch (highlight_code) {
				TEXT_STYLE_IMPORTANT:
					highlight_code = TEXT_STYLE_NOTE;
				TEXT_STYLE_MONOSPACED:
					highlight_code = TEXT_STYLE_USER1;
				TEXT_STYLE_NOTE:
					highlight_code = TEXT_STYLE_QUOTE;
				TEXT_STYLE_QUOTE:
					highlight_code = TEXT_STYLE_MONOSPACED;
				TEXT_STYLE_STRESSED:
					highlight_code = TEXT_STYLE_IMPORTANT;
				TEXT_STYLE_UPRIGHT, -1:
					highlight_code = TEXT_STYLE_STRESSED;
				TEXT_STYLE_USER1:
					highlight_code = TEXT_STYLE_UPRIGHT;
			}
			Utils.set_highlight_style(i, highlight_code);
		}
	}
	Utils.erase_window();
	Utils.write_configuration_file(CONFIG_FILE_NAME);
	Utils.set_status_bar_contents(0);
	<<Look>>;
];
#Ifnot; ! VERSION_WEB_MOBILE;
Verb meta 'destacado' 'resaltado'
	* Anything						-> NoSuchVerb
;

VerboIrregular "establecer configuración de palabras resaltadas"
 with	imperativo 'destacado' 'resaltado',
;
#Endif; ! VERSION_
#Endif; ! TARGET_GLULX;

!!------------------------------------------------------------------------------
!! ##ConfigureHyperlinks
!!------------------------------------------------------------------------------

#Ifdef TARGET_GLULX;
#Ifdef VERSION_DESKTOP;
Verb meta 'enlace' 'enlaces' 'hiperenlace' 'hiperenlaces' 'hipervinculo'
	'hipervinculos' 'vinculo' 'vinculos'
	*								-> ConfigureHyperlinks
;

VerboIrregular "establecer configuración de hipervínculos"
 with	imperativo 'enlace' 'enlaces' 'hiperenlace' 'hiperenlaces'
			'hipervinculo' 'hipervinculos' 'vinculo' 'vinculos',
;

[ ConfigureHyperlinksSub
	done i number_of_classes previous_style txt;
	number_of_classes = 4;
	txt = "INTRO";
	Utils.set_status_bar_contents("Hipervínculos");
	while (~~done) {
		Utils.erase_window();
		new_line;
		print "La obra permite interactuar con los distintos objetos presentes
		en el mundo utilizando un sistema de hipervínculos (haciendo ~clic~ con
		el ratón sobre los enlaces que vayan apareciendo). Existen cuatro
		clases de hipervínculo: 1) asociado a objetos importantes en la
		historia; 2) salidas y direcciones hacia las que puedes intentar
		desplazarte; 3) temas de conversación; y 4) otros objetos interactivos.
		Puedes activar o desactivar cada tipo de hipervínculo introduciendo el
		número de su clase:";
		new_line;
		new_line;
		for (i = 1 : i <= number_of_classes : i++) {
			switch (i) {
				1:	print "1) Objetos importantes: ";
				2:	print "2) Salidas y direcciones: ";
				3:	print "3) Temas de conversación: ";
				4:	print "4) Otros objetos: ";
			}
			if (Utils.get_hyperlinks_status(i)) {
				print "@<<activados@>>";
			} else {
				print (user2) "@<<desactivados@>>";
			}
			print ".";
			new_line;
		}
		new_line;
		previous_style = Utils.set_text_style(TEXT_STYLE_PARSER);
		print (string) TEXT_STYLE_PARSER_PREFIX;
		print "Pulsa @<<", (string) txt, "@>> para aceptar.";
		print (string) TEXT_STYLE_PARSER_SUFIX;
		Utils.set_text_style(previous_style);
		switch (Utils.press_any_key()) {
			32, -6: ! INTRO/ESPACIO
				done = true;
			'1':
				i = 1;
			'2':
				i = 2;
			'3':
				i = 3;
			'4':
				i = 4;
		}
		Utils.set_hyperlinks_status(i, ~~Utils.get_hyperlinks_status(i));
	}
	Utils.erase_window();
	Utils.write_configuration_file(CONFIG_FILE_NAME);
	Utils.set_status_bar_contents(0);
	<<Look>>;
];
#Ifnot; ! VERSION_WEB_MOBILE;
Verb meta 'enlace' 'enlaces' 'hiperenlace' 'hiperenlaces' 'hipervinculo'
	'hipervinculos' 'vinculo' 'vinculos'
		* Anything						-> NoSuchVerb
;

VerboIrregular "establecer configuración de hipervínculos"
 with	imperativo 'enlace' 'enlaces' 'hiperenlace' 'hiperenlaces'
			'hipervinculo' 'hipervinculos' 'vinculo' 'vinculos',
;
#Endif; ! VERSION_
#Endif; ! TARGET_GLULX;

!!------------------------------------------------------------------------------
!! ##DefaultAction
!!------------------------------------------------------------------------------
!!	Los objetos pueden definir una propiedad: 'action_set', con un array de
!!	acciones evidentes que pueden realizarse sobre ese objeto. Si definen esta
!!	propiedad, la acción por defecto imprime el listado de acciones. En caso
!!	contrario, la acción por defecto se limita a invocar la acción ##Examine
!!	sobre ese objeto.
!!------------------------------------------------------------------------------

Verb 'no.verb'
	* noun							-> DefaultAction
;

[ DefaultActionSub;
	!! Por evitar redundancias, cuando la instrucción por defecto lanza
	!! ##Examine sobre objetos generales, o ##Enter sobre objetos que
	!! representan salidas, no se imprime la aclaración de la entrada.
	!! 		previous_style = Utils.set_text_style(TEXT_STYLE_PARSER);
	!! 		print (string) TEXT_STYLE_PARSER_PREFIX;
	!! 		print "examina / ve";
	!! 		PrintToBuffer(utility_array_a, INPUT_BUFFER_LEN, self);
	!! 		PrintCharacterArray(utility_array_a);
	!! 		print (string) TEXT_STYLE_PARSER_SUFIX;
	!! 		Utils.set_text_style(previous_style);
	!! 		new_line;
	if (noun ofclass AdjacentRoom) <<Enter noun>>;
	else <<Examine noun>>;
];

!!------------------------------------------------------------------------------
!! ##Dig
!!------------------------------------------------------------------------------

Extend 'cava' first
	*								-> Dig
;

!!------------------------------------------------------------------------------
!! ##Enter
!!------------------------------------------------------------------------------

Verb	'escapa' 'huye'
	*								-> VagueGo
	* noun=ADirection				-> Go
	* 'a//' noun=ADirection			-> Go
	* 'hacia' noun=ADirection		-> Go
	* noun							-> Enter
	* 'a//' noun					-> Enter
	* 'hacia' noun					-> Enter
	* 'por' noun					-> Enter
;
VerboIrregular "huir" with imperativo 'huye';

!!------------------------------------------------------------------------------
!! ##GetDressed
!!------------------------------------------------------------------------------
!! Simplificación de la acción ##Wear que permite no incluir un objeto
!! objetivo. Comprueba si hay algún objeto de vestuario sin poner al alcance
!! del PC y lanza ##Wear sobre él en caso de encontrarlo, o imprime un mensaje
!! de error adecuado en caso contrario.
!!------------------------------------------------------------------------------

[ PresentClothes
	held_clothes i obj result;
	result = nothing;
	objectloop(obj has clothing
		&& TestScope(obj, player)) {
		result = obj;
		i++;
		if (parent(obj) == player) {
			result = obj;
			held_clothes++;
		}
	}
	if (held_clothes > 1 || (i-held_clothes) > 1) {
		result = GPR_FAIL;
	}
	return result;
];

Extend	only 'viste' 'vistete' 'vestirse' 'vestirte' 'vestirme' 'visteme' first
	* PresentClothes				-> GetDressed
;

[ GetDressedSub;
	!! 1) No hay ningún objeto de vestuario disponible:
	if (noun == nothing) {
		switch (Utils.get_grammatical_inflection()) {
			FIRST_PERSON_PRESENT:
				if (IsPluralNoun(player)) "No tenemos qué ponernos.";
				else "No tengo qué ponerme.";
			SECOND_PERSON_PRESENT:
				if (IsPluralNoun(player)) "No tenéis qué poneros.";
				else "No tienes qué ponerte.";
			THIRD_PERSON_PRESENT:
				if (IsPluralNoun(player)) "No tienen qué ponerse.";
				else "No tiene qué ponerse.";
			FIRST_PERSON_PAST:
				if (IsPluralNoun(player)) "No teníamos qué ponernos.";
				else "No tenía qué ponerme.";
			SECOND_PERSON_PAST:
				if (IsPluralNoun(player)) "No teníais qué poneros.";
				else "No tenías qué ponerte.";
			THIRD_PERSON_PAST:
				if (IsPluralNoun(player)) "No tenían qué ponerse.";
				else "No tenía qué ponerse.";
			FIRST_PERSON_FUTURE:
				if (IsPluralNoun(player)) "No tendremos qué ponernos.";
				else "No tendré qué ponerme.";
			SECOND_PERSON_FUTURE:
				if (IsPluralNoun(player)) "No tendréis qué poneros.";
				else "No tendrás qué ponerte.";
			THIRD_PERSON_FUTURE:
				if (IsPluralNoun(player)) "No tendrán qué ponerse.";
				else "No tendrá qué ponerse.";
		}
	}

	!! 2) El PC ya lleva puesto el objeto de vestuario:
	if (parent(noun) == player && noun has worn) {
		switch (Utils.get_grammatical_inflection()) {
			FIRST_PERSON_PRESENT:
				if (IsPluralNoun(player)) print "Ya llevamos";
				else print "Ya llevo";
			SECOND_PERSON_PRESENT:
				if (IsPluralNoun(player)) print "Ya lleváis";
				else print "Ya llevas";
			THIRD_PERSON_PRESENT:
				if (IsPluralNoun(player)) print "Ya llevan";
				else print "Ya lleva";
			FIRST_PERSON_PAST:
				if (IsPluralNoun(player)) print "Ya llevábamos";
				else print "Ya llevaba";
			SECOND_PERSON_PAST:
				if (IsPluralNoun(player)) print "Ya llevabais";
				else print "Ya llevabas";
			THIRD_PERSON_PAST:
				if (IsPluralNoun(player)) print "Ya llevaban";
				else print "Ya llevaba";
			FIRST_PERSON_FUTURE:
				if (IsPluralNoun(player)) print "Ya llevaremos";
				else print "Ya llevaré";
			SECOND_PERSON_FUTURE:
				if (IsPluralNoun(player)) print "Ya llevaréis";
				else print "Ya llevarás";
			THIRD_PERSON_FUTURE:
				if (IsPluralNoun(player)) print "Ya llevarán";
				else print "Ya llevará";
		}
		" ", (the) noun, " puest", (o) noun, ".";
	}

	!! 3) El objeto de vestuario está en posesión del PC pero no lo lleva
	!! puesto:
	if (parent(noun) == player && noun hasnt worn) {
		<<Wear noun>>;
	}

	!! 4) El objeto de vestuario no está en posesión del PC:
	if (parent(noun) ~= player) {
		print "(Primero";
		switch (Utils.get_grammatical_inflection()) {
			FIRST_PERSON_PRESENT:
				if (~~IsPluralNoun(player)) print " trato";
				else print " tratamos";
			SECOND_PERSON_PRESENT:
				if (~~IsPluralNoun(player)) print " tratas";
				else print " tratáis";
			THIRD_PERSON_PRESENT:
				if (~~IsPluralNoun(player)) print " trata";
				else print " tratan";
			FIRST_PERSON_PAST:
				if (~~IsPluralNoun(player)) print " traté";
				else print " tratamos";
			SECOND_PERSON_PAST:
				if (~~IsPluralNoun(player)) print " trataste";
				else print " tratasteis";
			THIRD_PERSON_PAST:
				if (~~IsPluralNoun(player)) print " trató";
				else print " trataron";
			FIRST_PERSON_FUTURE:
				if (~~IsPluralNoun(player)) print " trataré";
				else print " trataremos";
			SECOND_PERSON_FUTURE:
				if (~~IsPluralNoun(player)) print " tratarás";
				else print " trataréis";
			THIRD_PERSON_FUTURE:
				if (~~IsPluralNoun(player)) print " tratará";
				else print " tratarán";
		}
		print " de coger ", (the) noun, ".)";
		new_line;
		keep_silent = true;
		if (~~TakeSub()) {
			keep_silent = false;
			return true;
		}
		keep_silent = false;
		<<Wear noun>>;
	}
];

!! Extend 'ponte' first
!! 	* clothing					-> Wear
!! 	* 'con' clothing			-> Wear
!! ;
!!
!! Extend 'viste' first
!! 	*							-> GetDressed
!! 	* clothing					-> Wear
!! 	* 'con' clothing			-> Wear
!! ;

!!------------------------------------------------------------------------------
!! ##Go
!!
!!	@see ##Enter
!!------------------------------------------------------------------------------

!!------------------------------------------------------------------------------
!! ##Help
!!------------------------------------------------------------------------------

Verb meta 'ayuda' 'pista' 'pistas'
	*								-> Help
;
VerboIrregular "mostrar ayuda" with imperativo 'ayuda';

!! TODO
[ HelpSub;
	"", (parser) "Sistema de ayuda no disponible.";
];

!!------------------------------------------------------------------------------
!! ##LMode2
!!------------------------------------------------------------------------------

Extend only 'normal' replace
    *								-> LMode2
;

!!------------------------------------------------------------------------------
!! ##NoSuchVerb
!!------------------------------------------------------------------------------
!! Permite eliminar acciones definidas automáticamente por la librería Inform.
!! Código extraído de <http://www.firthworks.com/roger/informfaq/vv.html#6>.
!!------------------------------------------------------------------------------

Extend 'nx' replace
	* Anything						-> NoSuchVerb
;

Extend 'perdona' replace
	* Anything						-> NoSuchVerb
;

Extend 'saborea' replace
	* Anything						-> NoSuchVerb
;

[ NoSuchVerbSub; return ParserError(VERB_PE); ];

!!------------------------------------------------------------------------------
!! ##TalkOn / ##TalkTo
!!------------------------------------------------------------------------------

Extend	'habla' replace
	* noun							-> TalkTo
	* 'a'/'con' noun				-> TalkTo
	* creature						-> TalkTo
	* 'a'/'con' creature			-> TalkTo
	* 'por' noun					-> TalkOn
	* 'por' creature				-> TalkOn
;

Verb	'conversa' 'platica'
	* noun							-> TalkTo
	* 'a'/'con' noun				-> TalkTo
	* creature						-> TalkTo
	* 'a'/'con' creature			-> TalkTo
	* 'por' noun					-> TalkOn
	* 'por' creature				-> TalkOn
;

[ TalkOnSub
	previous_style;
	previous_style = Utils.set_text_style(TEXT_STYLE_PARSER);
	print (string) TEXT_STYLE_PARSER_PREFIX;
	print "Hablar con ", (name) noun;
	print (string) TEXT_STYLE_PARSER_SUFIX;
	Utils.set_text_style(previous_style);
	new_line;
	<<TalkTo noun second>>;
];

[ TalkToSub;
	!! 1) El personaje intenta hablar consigo mismo:
	if ( noun == player ) {
		print "Hablar con un", (o) player, " mism", (o) player, " ";
		switch (Utils.get_grammatical_inflection()) {
			FIRST_PERSON_PRESENT,
			SECOND_PERSON_PRESENT,
			THIRD_PERSON_PRESENT:
				"no resulta especialmente interesante.";
			FIRST_PERSON_PAST,
			SECOND_PERSON_PAST,
			THIRD_PERSON_PAST:
				"no resultaba especialmente interesante.";
			FIRST_PERSON_FUTURE,
			SECOND_PERSON_FUTURE,
			THIRD_PERSON_FUTURE:
				"no resultará especialmente interesante.";
		}
	}
	!! 2) El personaje intenta hablar con un objeto inanimado:
	if ( noun hasnt animate ) {
		switch (Utils.get_grammatical_inflection()) {
			FIRST_PERSON_PRESENT,
			SECOND_PERSON_PRESENT,
			THIRD_PERSON_PRESENT:
				"Sería más interesante intentar hablar con cosas que puedan
				devolver una respuesta.";
			FIRST_PERSON_PAST,
			SECOND_PERSON_PAST,
			THIRD_PERSON_PAST:
				"Hubiese sido más interesante intentar hablar con cosas que
				pudiesen devolver una respuesta.";
			FIRST_PERSON_FUTURE,
			SECOND_PERSON_FUTURE,
			THIRD_PERSON_FUTURE:
				"Será más interesante intentar hablar con cosas que puedan
				devolver una respuesta.";
		}
	}
	!! 3) El personaje intenta hablar con un objeto animado:
	switch (Utils.get_grammatical_inflection()) {
		FIRST_PERSON_PRESENT:
		SECOND_PERSON_PRESENT,
		THIRD_PERSON_PRESENT:
			print (The) noun, " no parecen", (n) noun;
		FIRST_PERSON_PAST,
		SECOND_PERSON_PAST,
		THIRD_PERSON_PAST:
			print (The) noun, " no parecía", (n) noun;
		FIRST_PERSON_FUTURE,
		SECOND_PERSON_FUTURE,
		THIRD_PERSON_FUTURE:
			print (The) noun, " no parecerá", (n) noun;
	}
	" interesad", (o) noun, " en hablar ", (contigo) player, ".";
];

!!------------------------------------------------------------------------------
!! ##VagueGo
!!
!!	@see ##Enter
!!------------------------------------------------------------------------------


!!==============================================================================
!!
!!	8)	Definición de atributos, clases y objetos
!!
!!------------------------------------------------------------------------------

Include ">baron_classes.inf";
Include ">baron_menu.inf";
Include ">baron_tutorial.inf";
Include ">baron_utils.inf";

Include ">baron_scene-zero.inf";
Include ">baron_scene-one.inf";
Include ">baron_scene-two.inf";
Include ">baron_scene-three.inf";
Include ">baron_scene-four.inf";
Include ">baron_scene-five.inf";
Include ">baron_scene-six.inf";
Include ">baron_scene-seven.inf";
